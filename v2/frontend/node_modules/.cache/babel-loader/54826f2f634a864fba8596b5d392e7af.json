{"ast":null,"code":"var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (var i = 0; i < chars.length; i++) {\n  charToInteger[chars.charCodeAt(i)] = i;\n}\n\nfunction decode(mappings) {\n  var decoded = [];\n  var line = [];\n  var segment = [0, 0, 0, 0, 0];\n  var j = 0;\n\n  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n    var c = mappings.charCodeAt(i);\n\n    if (c === 44) {\n      // \",\"\n      segmentify(line, segment, j);\n      j = 0;\n    } else if (c === 59) {\n      // \";\"\n      segmentify(line, segment, j);\n      j = 0;\n      decoded.push(line);\n      line = [];\n      segment[0] = 0;\n    } else {\n      var integer = charToInteger[c];\n\n      if (integer === undefined) {\n        throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n      }\n\n      var hasContinuationBit = integer & 32;\n      integer &= 31;\n      value += integer << shift;\n\n      if (hasContinuationBit) {\n        shift += 5;\n      } else {\n        var shouldNegate = value & 1;\n        value >>>= 1;\n\n        if (shouldNegate) {\n          value = value === 0 ? -0x80000000 : -value;\n        }\n\n        segment[j] += value;\n        j++;\n        value = shift = 0; // reset\n      }\n    }\n  }\n\n  segmentify(line, segment, j);\n  decoded.push(line);\n  return decoded;\n}\n\nfunction segmentify(line, segment, j) {\n  // This looks ugly, but we're creating specialized arrays with a specific\n  // length. This is much faster than creating a new array (which v8 expands to\n  // a capacity of 17 after pushing the first item), or slicing out a subarray\n  // (which is slow). Length 4 is assumed to be the most frequent, followed by\n  // length 5 (since not everything will have an associated name), followed by\n  // length 1 (it's probably rare for a source substring to not have an\n  // associated segment data).\n  if (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);else if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);else if (j === 1) line.push([segment[0]]);\n}\n\nfunction encode(decoded) {\n  var sourceFileIndex = 0; // second field\n\n  var sourceCodeLine = 0; // third field\n\n  var sourceCodeColumn = 0; // fourth field\n\n  var nameIndex = 0; // fifth field\n\n  var mappings = '';\n\n  for (var i = 0; i < decoded.length; i++) {\n    var line = decoded[i];\n    if (i > 0) mappings += ';';\n    if (line.length === 0) continue;\n    var generatedCodeColumn = 0; // first field\n\n    var lineMappings = [];\n\n    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n      var segment = line_1[_i];\n      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n      generatedCodeColumn = segment[0];\n\n      if (segment.length > 1) {\n        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);\n        sourceFileIndex = segment[1];\n        sourceCodeLine = segment[2];\n        sourceCodeColumn = segment[3];\n      }\n\n      if (segment.length === 5) {\n        segmentMappings += encodeInteger(segment[4] - nameIndex);\n        nameIndex = segment[4];\n      }\n\n      lineMappings.push(segmentMappings);\n    }\n\n    mappings += lineMappings.join(',');\n  }\n\n  return mappings;\n}\n\nfunction encodeInteger(num) {\n  var result = '';\n  num = num < 0 ? -num << 1 | 1 : num << 1;\n\n  do {\n    var clamped = num & 31;\n    num >>>= 5;\n\n    if (num > 0) {\n      clamped |= 32;\n    }\n\n    result += chars[clamped];\n  } while (num > 0);\n\n  return result;\n}\n\nexport { decode, encode };","map":{"version":3,"mappings":"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","names":["charToInteger","chars","i","length","charCodeAt","decode","mappings","decoded","line","segment","j","shift","value","c","segmentify","push","integer","undefined","Error","String","fromCharCode","hasContinuationBit","shouldNegate","encode","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","generatedCodeColumn","lineMappings","_i","segmentMappings","encodeInteger","join","num","result","clamped"],"sources":["/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/sourcemap-codec/src/sourcemap-codec.ts"],"sourcesContent":["export type SourceMapSegment =\n\t| [number]\n\t| [number, number, number, number]\n\t| [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst charToInteger: { [charCode: number]: number } = {};\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (let i = 0; i < chars.length; i++) {\n\tcharToInteger[chars.charCodeAt(i)] = i;\n}\n\nexport function decode(mappings: string): SourceMapMappings {\n\tconst decoded: SourceMapMappings = [];\n\tlet line: SourceMapLine = [];\n\tconst segment: SourceMapSegment = [\n\t\t0, // generated code column\n\t\t0, // source file index\n\t\t0, // source code line\n\t\t0, // source code column\n\t\t0, // name index\n\t];\n\n\tlet j = 0;\n\tfor (let i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n\t\tconst c = mappings.charCodeAt(i);\n\n\t\tif (c === 44) { // \",\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\n\t\t} else if (c === 59) { // \";\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\t\t\tdecoded.push(line);\n\t\t\tline = [];\n\t\t\tsegment[0] = 0;\n\n\t\t} else {\n\t\t\tlet integer = charToInteger[c];\n\t\t\tif (integer === undefined) {\n\t\t\t\tthrow new Error('Invalid character (' + String.fromCharCode(c) + ')');\n\t\t\t}\n\n\t\t\tconst hasContinuationBit = integer & 32;\n\n\t\t\tinteger &= 31;\n\t\t\tvalue += integer << shift;\n\n\t\t\tif (hasContinuationBit) {\n\t\t\t\tshift += 5;\n\t\t\t} else {\n\t\t\t\tconst shouldNegate = value & 1;\n\t\t\t\tvalue >>>= 1;\n\n\t\t\t\tif (shouldNegate) {\n\t\t\t\t\tvalue = value === 0 ? -0x80000000 : -value;\n\t\t\t\t}\n\n\t\t\t\tsegment[j] += value;\n\t\t\t\tj++;\n\t\t\t\tvalue = shift = 0; // reset\n\t\t\t}\n\t\t}\n\t}\n\n\tsegmentify(line, segment, j);\n\tdecoded.push(line);\n\n\treturn decoded;\n}\n\nfunction segmentify(line: SourceMapSegment[], segment: SourceMapSegment, j: number) {\n\t// This looks ugly, but we're creating specialized arrays with a specific\n\t// length. This is much faster than creating a new array (which v8 expands to\n\t// a capacity of 17 after pushing the first item), or slicing out a subarray\n\t// (which is slow). Length 4 is assumed to be the most frequent, followed by\n\t// length 5 (since not everything will have an associated name), followed by\n\t// length 1 (it's probably rare for a source substring to not have an\n\t// associated segment data).\n\tif (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);\n\telse if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n\telse if (j === 1) line.push([segment[0]]);\n}\n\nexport function encode(decoded: SourceMapMappings): string {\n\tlet sourceFileIndex = 0;  // second field\n\tlet sourceCodeLine = 0;   // third field\n\tlet sourceCodeColumn = 0; // fourth field\n\tlet nameIndex = 0;        // fifth field\n\tlet mappings = '';\n\n\tfor (let i = 0; i < decoded.length; i++) {\n\t\tconst line = decoded[i];\n\t\tif (i > 0) mappings += ';';\n\t\tif (line.length === 0) continue;\n\n\t\tlet generatedCodeColumn = 0; // first field\n\n\t\tconst lineMappings: string[] = [];\n\n\t\tfor (const segment of line) {\n\t\t\tlet segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n\t\t\tgeneratedCodeColumn = segment[0];\n\n\t\t\tif (segment.length > 1) {\n\t\t\t\tsegmentMappings +=\n\t\t\t\t\tencodeInteger(segment[1] - sourceFileIndex) +\n\t\t\t\t\tencodeInteger(segment[2] - sourceCodeLine) +\n\t\t\t\t\tencodeInteger(segment[3] - sourceCodeColumn);\n\n\t\t\t\tsourceFileIndex = segment[1];\n\t\t\t\tsourceCodeLine = segment[2];\n\t\t\t\tsourceCodeColumn = segment[3];\n\t\t\t}\n\n\t\t\tif (segment.length === 5) {\n\t\t\t\tsegmentMappings += encodeInteger(segment[4] - nameIndex);\n\t\t\t\tnameIndex = segment[4];\n\t\t\t}\n\n\t\t\tlineMappings.push(segmentMappings);\n\t\t}\n\n\t\tmappings += lineMappings.join(',');\n\t}\n\n\treturn mappings;\n}\n\nfunction encodeInteger(num: number): string {\n\tvar result = '';\n\tnum = num < 0 ? (-num << 1) | 1 : num << 1;\n\tdo {\n\t\tvar clamped = num & 31;\n\t\tnum >>>= 5;\n\t\tif (num > 0) {\n\t\t\tclamped |= 32;\n\t\t}\n\t\tresult += chars[clamped];\n\t} while (num > 0);\n\n\treturn result;\n}\n"]},"metadata":{},"sourceType":"module"}