{"ast":null,"code":"import { encode } from 'sourcemap-codec';\n\nvar BitSet = function BitSet(arg) {\n  this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n};\n\nBitSet.prototype.add = function add(n) {\n  this.bits[n >> 5] |= 1 << (n & 31);\n};\n\nBitSet.prototype.has = function has(n) {\n  return !!(this.bits[n >> 5] & 1 << (n & 31));\n};\n\nvar Chunk = function Chunk(start, end, content) {\n  this.start = start;\n  this.end = end;\n  this.original = content;\n  this.intro = '';\n  this.outro = '';\n  this.content = content;\n  this.storeName = false;\n  this.edited = false; // we make these non-enumerable, for sanity while debugging\n\n  Object.defineProperties(this, {\n    previous: {\n      writable: true,\n      value: null\n    },\n    next: {\n      writable: true,\n      value: null\n    }\n  });\n};\n\nChunk.prototype.appendLeft = function appendLeft(content) {\n  this.outro += content;\n};\n\nChunk.prototype.appendRight = function appendRight(content) {\n  this.intro = this.intro + content;\n};\n\nChunk.prototype.clone = function clone() {\n  var chunk = new Chunk(this.start, this.end, this.original);\n  chunk.intro = this.intro;\n  chunk.outro = this.outro;\n  chunk.content = this.content;\n  chunk.storeName = this.storeName;\n  chunk.edited = this.edited;\n  return chunk;\n};\n\nChunk.prototype.contains = function contains(index) {\n  return this.start < index && index < this.end;\n};\n\nChunk.prototype.eachNext = function eachNext(fn) {\n  var chunk = this;\n\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.next;\n  }\n};\n\nChunk.prototype.eachPrevious = function eachPrevious(fn) {\n  var chunk = this;\n\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.previous;\n  }\n};\n\nChunk.prototype.edit = function edit(content, storeName, contentOnly) {\n  this.content = content;\n\n  if (!contentOnly) {\n    this.intro = '';\n    this.outro = '';\n  }\n\n  this.storeName = storeName;\n  this.edited = true;\n  return this;\n};\n\nChunk.prototype.prependLeft = function prependLeft(content) {\n  this.outro = content + this.outro;\n};\n\nChunk.prototype.prependRight = function prependRight(content) {\n  this.intro = content + this.intro;\n};\n\nChunk.prototype.split = function split(index) {\n  var sliceIndex = index - this.start;\n  var originalBefore = this.original.slice(0, sliceIndex);\n  var originalAfter = this.original.slice(sliceIndex);\n  this.original = originalBefore;\n  var newChunk = new Chunk(index, this.end, originalAfter);\n  newChunk.outro = this.outro;\n  this.outro = '';\n  this.end = index;\n\n  if (this.edited) {\n    // TODO is this block necessary?...\n    newChunk.edit('', false);\n    this.content = '';\n  } else {\n    this.content = originalBefore;\n  }\n\n  newChunk.next = this.next;\n\n  if (newChunk.next) {\n    newChunk.next.previous = newChunk;\n  }\n\n  newChunk.previous = this;\n  this.next = newChunk;\n  return newChunk;\n};\n\nChunk.prototype.toString = function toString() {\n  return this.intro + this.content + this.outro;\n};\n\nChunk.prototype.trimEnd = function trimEnd(rx) {\n  this.outro = this.outro.replace(rx, '');\n\n  if (this.outro.length) {\n    return true;\n  }\n\n  var trimmed = this.content.replace(rx, '');\n\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.start + trimmed.length).edit('', undefined, true);\n    }\n\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.intro = this.intro.replace(rx, '');\n\n    if (this.intro.length) {\n      return true;\n    }\n  }\n};\n\nChunk.prototype.trimStart = function trimStart(rx) {\n  this.intro = this.intro.replace(rx, '');\n\n  if (this.intro.length) {\n    return true;\n  }\n\n  var trimmed = this.content.replace(rx, '');\n\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.end - trimmed.length);\n      this.edit('', undefined, true);\n    }\n\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.outro = this.outro.replace(rx, '');\n\n    if (this.outro.length) {\n      return true;\n    }\n  }\n};\n\nvar btoa = function () {\n  throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n  btoa = function (str) {\n    return window.btoa(unescape(encodeURIComponent(str)));\n  };\n} else if (typeof Buffer === 'function') {\n  btoa = function (str) {\n    return Buffer.from(str, 'utf-8').toString('base64');\n  };\n}\n\nvar SourceMap = function SourceMap(properties) {\n  this.version = 3;\n  this.file = properties.file;\n  this.sources = properties.sources;\n  this.sourcesContent = properties.sourcesContent;\n  this.names = properties.names;\n  this.mappings = encode(properties.mappings);\n};\n\nSourceMap.prototype.toString = function toString() {\n  return JSON.stringify(this);\n};\n\nSourceMap.prototype.toUrl = function toUrl() {\n  return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n};\n\nfunction guessIndent(code) {\n  var lines = code.split('\\n');\n  var tabbed = lines.filter(function (line) {\n    return /^\\t+/.test(line);\n  });\n  var spaced = lines.filter(function (line) {\n    return /^ {2,}/.test(line);\n  });\n\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  } // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n\n\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  } // Otherwise, we need to guess the multiple\n\n\n  var min = spaced.reduce(function (previous, current) {\n    var numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n  var fromParts = from.split(/[/\\\\]/);\n  var toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n\n  if (fromParts.length) {\n    var i = fromParts.length;\n\n    while (i--) {\n      fromParts[i] = '..';\n    }\n  }\n\n  return fromParts.concat(toParts).join('/');\n}\n\nvar toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n  var originalLines = source.split('\\n');\n  var lineOffsets = [];\n\n  for (var i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n\n  return function locate(index) {\n    var i = 0;\n    var j = lineOffsets.length;\n\n    while (i < j) {\n      var m = i + j >> 1;\n\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n\n    var line = i - 1;\n    var column = index - lineOffsets[line];\n    return {\n      line: line,\n      column: column\n    };\n  };\n}\n\nvar Mappings = function Mappings(hires) {\n  this.hires = hires;\n  this.generatedCodeLine = 0;\n  this.generatedCodeColumn = 0;\n  this.raw = [];\n  this.rawSegments = this.raw[this.generatedCodeLine] = [];\n  this.pending = null;\n};\n\nMappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {\n  if (content.length) {\n    var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n    if (nameIndex >= 0) {\n      segment.push(nameIndex);\n    }\n\n    this.rawSegments.push(segment);\n  } else if (this.pending) {\n    this.rawSegments.push(this.pending);\n  }\n\n  this.advance(content);\n  this.pending = null;\n};\n\nMappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n  var originalCharIndex = chunk.start;\n  var first = true;\n\n  while (originalCharIndex < chunk.end) {\n    if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n      this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n    }\n\n    if (original[originalCharIndex] === '\\n') {\n      loc.line += 1;\n      loc.column = 0;\n      this.generatedCodeLine += 1;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      this.generatedCodeColumn = 0;\n      first = true;\n    } else {\n      loc.column += 1;\n      this.generatedCodeColumn += 1;\n      first = false;\n    }\n\n    originalCharIndex += 1;\n  }\n\n  this.pending = null;\n};\n\nMappings.prototype.advance = function advance(str) {\n  if (!str) {\n    return;\n  }\n\n  var lines = str.split('\\n');\n\n  if (lines.length > 1) {\n    for (var i = 0; i < lines.length - 1; i++) {\n      this.generatedCodeLine++;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n    }\n\n    this.generatedCodeColumn = 0;\n  }\n\n  this.generatedCodeColumn += lines[lines.length - 1].length;\n};\n\nvar n = '\\n';\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\n\nvar MagicString = function MagicString(string, options) {\n  if (options === void 0) options = {};\n  var chunk = new Chunk(0, string.length, string);\n  Object.defineProperties(this, {\n    original: {\n      writable: true,\n      value: string\n    },\n    outro: {\n      writable: true,\n      value: ''\n    },\n    intro: {\n      writable: true,\n      value: ''\n    },\n    firstChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastSearchedChunk: {\n      writable: true,\n      value: chunk\n    },\n    byStart: {\n      writable: true,\n      value: {}\n    },\n    byEnd: {\n      writable: true,\n      value: {}\n    },\n    filename: {\n      writable: true,\n      value: options.filename\n    },\n    indentExclusionRanges: {\n      writable: true,\n      value: options.indentExclusionRanges\n    },\n    sourcemapLocations: {\n      writable: true,\n      value: new BitSet()\n    },\n    storedNames: {\n      writable: true,\n      value: {}\n    },\n    indentStr: {\n      writable: true,\n      value: guessIndent(string)\n    }\n  });\n  this.byStart[0] = chunk;\n  this.byEnd[string.length] = chunk;\n};\n\nMagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {\n  this.sourcemapLocations.add(char);\n};\n\nMagicString.prototype.append = function append(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n\n  this.outro += content;\n  return this;\n};\n\nMagicString.prototype.appendLeft = function appendLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byEnd[index];\n\n  if (chunk) {\n    chunk.appendLeft(content);\n  } else {\n    this.intro += content;\n  }\n\n  return this;\n};\n\nMagicString.prototype.appendRight = function appendRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byStart[index];\n\n  if (chunk) {\n    chunk.appendRight(content);\n  } else {\n    this.outro += content;\n  }\n\n  return this;\n};\n\nMagicString.prototype.clone = function clone() {\n  var cloned = new MagicString(this.original, {\n    filename: this.filename\n  });\n  var originalChunk = this.firstChunk;\n  var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n\n  while (originalChunk) {\n    cloned.byStart[clonedChunk.start] = clonedChunk;\n    cloned.byEnd[clonedChunk.end] = clonedChunk;\n    var nextOriginalChunk = originalChunk.next;\n    var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n    if (nextClonedChunk) {\n      clonedChunk.next = nextClonedChunk;\n      nextClonedChunk.previous = clonedChunk;\n      clonedChunk = nextClonedChunk;\n    }\n\n    originalChunk = nextOriginalChunk;\n  }\n\n  cloned.lastChunk = clonedChunk;\n\n  if (this.indentExclusionRanges) {\n    cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n  }\n\n  cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n  cloned.intro = this.intro;\n  cloned.outro = this.outro;\n  return cloned;\n};\n\nMagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1$1 = this;\n  options = options || {};\n  var sourceIndex = 0;\n  var names = Object.keys(this.storedNames);\n  var mappings = new Mappings(options.hires);\n  var locate = getLocator(this.original);\n\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n\n  this.firstChunk.eachNext(function (chunk) {\n    var loc = locate(chunk.start);\n\n    if (chunk.intro.length) {\n      mappings.advance(chunk.intro);\n    }\n\n    if (chunk.edited) {\n      mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n    } else {\n      mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);\n    }\n\n    if (chunk.outro.length) {\n      mappings.advance(chunk.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n    sourcesContent: options.includeContent ? [this.original] : [null],\n    names: names,\n    mappings: mappings.raw\n  };\n};\n\nMagicString.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\n\nMagicString.prototype.getIndentString = function getIndentString() {\n  return this.indentStr === null ? '\\t' : this.indentStr;\n};\n\nMagicString.prototype.indent = function indent(indentStr, options) {\n  var pattern = /^[^\\r\\n]/gm;\n\n  if (isObject(indentStr)) {\n    options = indentStr;\n    indentStr = undefined;\n  }\n\n  indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n\n  options = options || {}; // Process exclusion ranges\n\n  var isExcluded = {};\n\n  if (options.exclude) {\n    var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n    exclusions.forEach(function (exclusion) {\n      for (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n        isExcluded[i] = true;\n      }\n    });\n  }\n\n  var shouldIndentNextCharacter = options.indentStart !== false;\n\n  var replacer = function (match) {\n    if (shouldIndentNextCharacter) {\n      return \"\" + indentStr + match;\n    }\n\n    shouldIndentNextCharacter = true;\n    return match;\n  };\n\n  this.intro = this.intro.replace(pattern, replacer);\n  var charIndex = 0;\n  var chunk = this.firstChunk;\n\n  while (chunk) {\n    var end = chunk.end;\n\n    if (chunk.edited) {\n      if (!isExcluded[charIndex]) {\n        chunk.content = chunk.content.replace(pattern, replacer);\n\n        if (chunk.content.length) {\n          shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n        }\n      }\n    } else {\n      charIndex = chunk.start;\n\n      while (charIndex < end) {\n        if (!isExcluded[charIndex]) {\n          var char = this.original[charIndex];\n\n          if (char === '\\n') {\n            shouldIndentNextCharacter = true;\n          } else if (char !== '\\r' && shouldIndentNextCharacter) {\n            shouldIndentNextCharacter = false;\n\n            if (charIndex === chunk.start) {\n              chunk.prependRight(indentStr);\n            } else {\n              this._splitChunk(chunk, charIndex);\n\n              chunk = chunk.next;\n              chunk.prependRight(indentStr);\n            }\n          }\n        }\n\n        charIndex += 1;\n      }\n    }\n\n    charIndex = chunk.end;\n    chunk = chunk.next;\n  }\n\n  this.outro = this.outro.replace(pattern, replacer);\n  return this;\n};\n\nMagicString.prototype.insert = function insert() {\n  throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n};\n\nMagicString.prototype.insertLeft = function insertLeft(index, content) {\n  if (!warned.insertLeft) {\n    console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\n    warned.insertLeft = true;\n  }\n\n  return this.appendLeft(index, content);\n};\n\nMagicString.prototype.insertRight = function insertRight(index, content) {\n  if (!warned.insertRight) {\n    console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\n    warned.insertRight = true;\n  }\n\n  return this.prependRight(index, content);\n};\n\nMagicString.prototype.move = function move(start, end, index) {\n  if (index >= start && index <= end) {\n    throw new Error('Cannot move a selection inside itself');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  this._split(index);\n\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n  var oldLeft = first.previous;\n  var oldRight = last.next;\n  var newRight = this.byStart[index];\n\n  if (!newRight && last === this.lastChunk) {\n    return this;\n  }\n\n  var newLeft = newRight ? newRight.previous : this.lastChunk;\n\n  if (oldLeft) {\n    oldLeft.next = oldRight;\n  }\n\n  if (oldRight) {\n    oldRight.previous = oldLeft;\n  }\n\n  if (newLeft) {\n    newLeft.next = first;\n  }\n\n  if (newRight) {\n    newRight.previous = last;\n  }\n\n  if (!first.previous) {\n    this.firstChunk = last.next;\n  }\n\n  if (!last.next) {\n    this.lastChunk = first.previous;\n    this.lastChunk.next = null;\n  }\n\n  first.previous = newLeft;\n  last.next = newRight || null;\n\n  if (!newLeft) {\n    this.firstChunk = first;\n  }\n\n  if (!newRight) {\n    this.lastChunk = last;\n  }\n\n  return this;\n};\n\nMagicString.prototype.overwrite = function overwrite(start, end, content, options) {\n  if (typeof content !== 'string') {\n    throw new TypeError('replacement content must be a string');\n  }\n\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  if (end > this.original.length) {\n    throw new Error('end is out of bounds');\n  }\n\n  if (start === end) {\n    throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  if (options === true) {\n    if (!warned.storeName) {\n      console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\n      warned.storeName = true;\n    }\n\n    options = {\n      storeName: true\n    };\n  }\n\n  var storeName = options !== undefined ? options.storeName : false;\n  var contentOnly = options !== undefined ? options.contentOnly : false;\n\n  if (storeName) {\n    var original = this.original.slice(start, end);\n    Object.defineProperty(this.storedNames, original, {\n      writable: true,\n      value: true,\n      enumerable: true\n    });\n  }\n\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n\n  if (first) {\n    var chunk = first;\n\n    while (chunk !== last) {\n      if (chunk.next !== this.byStart[chunk.end]) {\n        throw new Error('Cannot overwrite across a split point');\n      }\n\n      chunk = chunk.next;\n      chunk.edit('', false);\n    }\n\n    first.edit(content, storeName, contentOnly);\n  } else {\n    // must be inserting at the end\n    var newChunk = new Chunk(start, end, '').edit(content, storeName); // TODO last chunk in the array may not be the last chunk, if it's moved...\n\n    last.next = newChunk;\n    newChunk.previous = last;\n  }\n\n  return this;\n};\n\nMagicString.prototype.prepend = function prepend(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n\n  this.intro = content + this.intro;\n  return this;\n};\n\nMagicString.prototype.prependLeft = function prependLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byEnd[index];\n\n  if (chunk) {\n    chunk.prependLeft(content);\n  } else {\n    this.intro = content + this.intro;\n  }\n\n  return this;\n};\n\nMagicString.prototype.prependRight = function prependRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byStart[index];\n\n  if (chunk) {\n    chunk.prependRight(content);\n  } else {\n    this.outro = content + this.outro;\n  }\n\n  return this;\n};\n\nMagicString.prototype.remove = function remove(start, end) {\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  if (start === end) {\n    return this;\n  }\n\n  if (start < 0 || end > this.original.length) {\n    throw new Error('Character is out of bounds');\n  }\n\n  if (start > end) {\n    throw new Error('end must be greater than start');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  var chunk = this.byStart[start];\n\n  while (chunk) {\n    chunk.intro = '';\n    chunk.outro = '';\n    chunk.edit('');\n    chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n  }\n\n  return this;\n};\n\nMagicString.prototype.lastChar = function lastChar() {\n  if (this.outro.length) {\n    return this.outro[this.outro.length - 1];\n  }\n\n  var chunk = this.lastChunk;\n\n  do {\n    if (chunk.outro.length) {\n      return chunk.outro[chunk.outro.length - 1];\n    }\n\n    if (chunk.content.length) {\n      return chunk.content[chunk.content.length - 1];\n    }\n\n    if (chunk.intro.length) {\n      return chunk.intro[chunk.intro.length - 1];\n    }\n  } while (chunk = chunk.previous);\n\n  if (this.intro.length) {\n    return this.intro[this.intro.length - 1];\n  }\n\n  return '';\n};\n\nMagicString.prototype.lastLine = function lastLine() {\n  var lineIndex = this.outro.lastIndexOf(n);\n\n  if (lineIndex !== -1) {\n    return this.outro.substr(lineIndex + 1);\n  }\n\n  var lineStr = this.outro;\n  var chunk = this.lastChunk;\n\n  do {\n    if (chunk.outro.length > 0) {\n      lineIndex = chunk.outro.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.outro.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.outro + lineStr;\n    }\n\n    if (chunk.content.length > 0) {\n      lineIndex = chunk.content.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.content.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.content + lineStr;\n    }\n\n    if (chunk.intro.length > 0) {\n      lineIndex = chunk.intro.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.intro.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.intro + lineStr;\n    }\n  } while (chunk = chunk.previous);\n\n  lineIndex = this.intro.lastIndexOf(n);\n\n  if (lineIndex !== -1) {\n    return this.intro.substr(lineIndex + 1) + lineStr;\n  }\n\n  return this.intro + lineStr;\n};\n\nMagicString.prototype.slice = function slice(start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = this.original.length;\n\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  var result = ''; // find start chunk\n\n  var chunk = this.firstChunk;\n\n  while (chunk && (chunk.start > start || chunk.end <= start)) {\n    // found end chunk before start\n    if (chunk.start < end && chunk.end >= end) {\n      return result;\n    }\n\n    chunk = chunk.next;\n  }\n\n  if (chunk && chunk.edited && chunk.start !== start) {\n    throw new Error(\"Cannot use replaced character \" + start + \" as slice start anchor.\");\n  }\n\n  var startChunk = chunk;\n\n  while (chunk) {\n    if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n      result += chunk.intro;\n    }\n\n    var containsEnd = chunk.start < end && chunk.end >= end;\n\n    if (containsEnd && chunk.edited && chunk.end !== end) {\n      throw new Error(\"Cannot use replaced character \" + end + \" as slice end anchor.\");\n    }\n\n    var sliceStart = startChunk === chunk ? start - chunk.start : 0;\n    var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n    result += chunk.content.slice(sliceStart, sliceEnd);\n\n    if (chunk.outro && (!containsEnd || chunk.end === end)) {\n      result += chunk.outro;\n    }\n\n    if (containsEnd) {\n      break;\n    }\n\n    chunk = chunk.next;\n  }\n\n  return result;\n}; // TODO deprecate this? not really very useful\n\n\nMagicString.prototype.snip = function snip(start, end) {\n  var clone = this.clone();\n  clone.remove(0, start);\n  clone.remove(end, clone.original.length);\n  return clone;\n};\n\nMagicString.prototype._split = function _split(index) {\n  if (this.byStart[index] || this.byEnd[index]) {\n    return;\n  }\n\n  var chunk = this.lastSearchedChunk;\n  var searchForward = index > chunk.end;\n\n  while (chunk) {\n    if (chunk.contains(index)) {\n      return this._splitChunk(chunk, index);\n    }\n\n    chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n  }\n};\n\nMagicString.prototype._splitChunk = function _splitChunk(chunk, index) {\n  if (chunk.edited && chunk.content.length) {\n    // zero-length edited chunks are a special case (overlapping replacements)\n    var loc = getLocator(this.original)(index);\n    throw new Error(\"Cannot split a chunk that has already been edited (\" + loc.line + \":\" + loc.column + \" – \\\"\" + chunk.original + \"\\\")\");\n  }\n\n  var newChunk = chunk.split(index);\n  this.byEnd[index] = chunk;\n  this.byStart[index] = newChunk;\n  this.byEnd[newChunk.end] = newChunk;\n\n  if (chunk === this.lastChunk) {\n    this.lastChunk = newChunk;\n  }\n\n  this.lastSearchedChunk = chunk;\n  return true;\n};\n\nMagicString.prototype.toString = function toString() {\n  var str = this.intro;\n  var chunk = this.firstChunk;\n\n  while (chunk) {\n    str += chunk.toString();\n    chunk = chunk.next;\n  }\n\n  return str + this.outro;\n};\n\nMagicString.prototype.isEmpty = function isEmpty() {\n  var chunk = this.firstChunk;\n\n  do {\n    if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {\n      return false;\n    }\n  } while (chunk = chunk.next);\n\n  return true;\n};\n\nMagicString.prototype.length = function length() {\n  var chunk = this.firstChunk;\n  var length = 0;\n\n  do {\n    length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n  } while (chunk = chunk.next);\n\n  return length;\n};\n\nMagicString.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\n\nMagicString.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\n\nMagicString.prototype.trimEndAborted = function trimEndAborted(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  this.outro = this.outro.replace(rx, '');\n\n  if (this.outro.length) {\n    return true;\n  }\n\n  var chunk = this.lastChunk;\n\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimEnd(rx); // if chunk was trimmed, we have a new lastChunk\n\n    if (chunk.end !== end) {\n      if (this.lastChunk === chunk) {\n        this.lastChunk = chunk.next;\n      }\n\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n\n    if (aborted) {\n      return true;\n    }\n\n    chunk = chunk.previous;\n  } while (chunk);\n\n  return false;\n};\n\nMagicString.prototype.trimEnd = function trimEnd(charType) {\n  this.trimEndAborted(charType);\n  return this;\n};\n\nMagicString.prototype.trimStartAborted = function trimStartAborted(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n\n  if (this.intro.length) {\n    return true;\n  }\n\n  var chunk = this.firstChunk;\n\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimStart(rx);\n\n    if (chunk.end !== end) {\n      // special case...\n      if (chunk === this.lastChunk) {\n        this.lastChunk = chunk.next;\n      }\n\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n\n    if (aborted) {\n      return true;\n    }\n\n    chunk = chunk.next;\n  } while (chunk);\n\n  return false;\n};\n\nMagicString.prototype.trimStart = function trimStart(charType) {\n  this.trimStartAborted(charType);\n  return this;\n};\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar Bundle = function Bundle(options) {\n  if (options === void 0) options = {};\n  this.intro = options.intro || '';\n  this.separator = options.separator !== undefined ? options.separator : '\\n';\n  this.sources = [];\n  this.uniqueSources = [];\n  this.uniqueSourceIndexByFilename = {};\n};\n\nBundle.prototype.addSource = function addSource(source) {\n  if (source instanceof MagicString) {\n    return this.addSource({\n      content: source,\n      filename: source.filename,\n      separator: this.separator\n    });\n  }\n\n  if (!isObject(source) || !source.content) {\n    throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n  }\n\n  ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n    if (!hasOwnProp.call(source, option)) {\n      source[option] = source.content[option];\n    }\n  });\n\n  if (source.separator === undefined) {\n    // TODO there's a bunch of this sort of thing, needs cleaning up\n    source.separator = this.separator;\n  }\n\n  if (source.filename) {\n    if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n      this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n      this.uniqueSources.push({\n        filename: source.filename,\n        content: source.content.original\n      });\n    } else {\n      var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\n      if (source.content.original !== uniqueSource.content) {\n        throw new Error(\"Illegal source: same filename (\" + source.filename + \"), different contents\");\n      }\n    }\n  }\n\n  this.sources.push(source);\n  return this;\n};\n\nBundle.prototype.append = function append(str, options) {\n  this.addSource({\n    content: new MagicString(str),\n    separator: options && options.separator || ''\n  });\n  return this;\n};\n\nBundle.prototype.clone = function clone() {\n  var bundle = new Bundle({\n    intro: this.intro,\n    separator: this.separator\n  });\n  this.sources.forEach(function (source) {\n    bundle.addSource({\n      filename: source.filename,\n      content: source.content.clone(),\n      separator: source.separator\n    });\n  });\n  return bundle;\n};\n\nBundle.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1$1 = this;\n  if (options === void 0) options = {};\n  var names = [];\n  this.sources.forEach(function (source) {\n    Object.keys(source.content.storedNames).forEach(function (name) {\n      if (!~names.indexOf(name)) {\n        names.push(name);\n      }\n    });\n  });\n  var mappings = new Mappings(options.hires);\n\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n\n  this.sources.forEach(function (source, i) {\n    if (i > 0) {\n      mappings.advance(this$1$1.separator);\n    }\n\n    var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;\n    var magicString = source.content;\n    var locate = getLocator(magicString.original);\n\n    if (magicString.intro) {\n      mappings.advance(magicString.intro);\n    }\n\n    magicString.firstChunk.eachNext(function (chunk) {\n      var loc = locate(chunk.start);\n\n      if (chunk.intro.length) {\n        mappings.advance(chunk.intro);\n      }\n\n      if (source.filename) {\n        if (chunk.edited) {\n          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n        } else {\n          mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n        }\n      } else {\n        mappings.advance(chunk.content);\n      }\n\n      if (chunk.outro.length) {\n        mappings.advance(chunk.outro);\n      }\n    });\n\n    if (magicString.outro) {\n      mappings.advance(magicString.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: this.uniqueSources.map(function (source) {\n      return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n    }),\n    sourcesContent: this.uniqueSources.map(function (source) {\n      return options.includeContent ? source.content : null;\n    }),\n    names: names,\n    mappings: mappings.raw\n  };\n};\n\nBundle.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\n\nBundle.prototype.getIndentString = function getIndentString() {\n  var indentStringCounts = {};\n  this.sources.forEach(function (source) {\n    var indentStr = source.content.indentStr;\n\n    if (indentStr === null) {\n      return;\n    }\n\n    if (!indentStringCounts[indentStr]) {\n      indentStringCounts[indentStr] = 0;\n    }\n\n    indentStringCounts[indentStr] += 1;\n  });\n  return Object.keys(indentStringCounts).sort(function (a, b) {\n    return indentStringCounts[a] - indentStringCounts[b];\n  })[0] || '\\t';\n};\n\nBundle.prototype.indent = function indent(indentStr) {\n  var this$1$1 = this;\n\n  if (!arguments.length) {\n    indentStr = this.getIndentString();\n  }\n\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n\n  var trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n  this.sources.forEach(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1$1.separator;\n    var indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n    source.content.indent(indentStr, {\n      exclude: source.indentExclusionRanges,\n      indentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\n    });\n    trailingNewline = source.content.lastChar() === '\\n';\n  });\n\n  if (this.intro) {\n    this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, function (match, index) {\n      return index > 0 ? indentStr + match : match;\n    });\n  }\n\n  return this;\n};\n\nBundle.prototype.prepend = function prepend(str) {\n  this.intro = str + this.intro;\n  return this;\n};\n\nBundle.prototype.toString = function toString() {\n  var this$1$1 = this;\n  var body = this.sources.map(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1$1.separator;\n    var str = (i > 0 ? separator : '') + source.content.toString();\n    return str;\n  }).join('');\n  return this.intro + body;\n};\n\nBundle.prototype.isEmpty = function isEmpty() {\n  if (this.intro.length && this.intro.trim()) {\n    return false;\n  }\n\n  if (this.sources.some(function (source) {\n    return !source.content.isEmpty();\n  })) {\n    return false;\n  }\n\n  return true;\n};\n\nBundle.prototype.length = function length() {\n  return this.sources.reduce(function (length, source) {\n    return length + source.content.length();\n  }, this.intro.length);\n};\n\nBundle.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\n\nBundle.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\n\nBundle.prototype.trimStart = function trimStart(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n\n  if (!this.intro) {\n    var source;\n    var i = 0;\n\n    do {\n      source = this.sources[i++];\n\n      if (!source) {\n        break;\n      }\n    } while (!source.content.trimStartAborted(charType));\n  }\n\n  return this;\n};\n\nBundle.prototype.trimEnd = function trimEnd(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  var source;\n  var i = this.sources.length - 1;\n\n  do {\n    source = this.sources[i--];\n\n    if (!source) {\n      this.intro = this.intro.replace(rx, '');\n      break;\n    }\n  } while (!source.content.trimEndAborted(charType));\n\n  return this;\n};\n\nexport { Bundle, SourceMap, MagicString as default };","map":{"version":3,"mappings":"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","names":["BitSet","arg","bits","slice","add","n","has","Chunk","start","end","content","original","intro","outro","storeName","edited","Object","defineProperties","previous","writable","value","next","appendLeft","appendRight","clone","const","chunk","contains","index","eachNext","fn","let","eachPrevious","edit","contentOnly","prependLeft","prependRight","split","sliceIndex","originalBefore","originalAfter","newChunk","toString","trimEnd","rx","replace","length","trimmed","undefined","trimStart","btoa","Error","window","str","unescape","encodeURIComponent","Buffer","from","SourceMap","properties","version","file","sources","sourcesContent","names","mappings","encode","JSON","stringify","toUrl","guessIndent","code","lines","tabbed","filter","line","test","spaced","min","reduce","current","numSpaces","exec","Math","Infinity","Array","join","getRelativePath","to","fromParts","toParts","pop","shift","i","concat","prototype","isObject","thing","call","getLocator","source","originalLines","lineOffsets","pos","push","locate","j","m","column","Mappings","hires","generatedCodeLine","generatedCodeColumn","raw","rawSegments","pending","addEdit","sourceIndex","loc","nameIndex","segment","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","warned","insertLeft","insertRight","MagicString","string","options","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","filename","indentExclusionRanges","storedNames","indentStr","addSourcemapLocation","char","append","TypeError","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","keys","indexOf","this","includeContent","generateMap","getIndentString","indent","pattern","isExcluded","exclude","exclusions","forEach","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","console","warn","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","defineProperty","enumerable","prepend","remove","lastChar","lastLine","lineIndex","lastIndexOf","substr","lineStr","result","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trim","trimLines","charType","trimEndAborted","RegExp","aborted","trimStartAborted","hasOwnProp","hasOwnProperty","Bundle","separator","uniqueSources","uniqueSourceIndexByFilename","addSource","option","uniqueSource","bundle","name","magicString","map","indentStringCounts","sort","a","b","arguments","trailingNewline","body","some"],"sources":["/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/BitSet.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/Chunk.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/SourceMap.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/utils/guessIndent.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/utils/getRelativePath.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/utils/isObject.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/utils/getLocator.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/utils/Mappings.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/MagicString.js","/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/magic-string/src/Bundle.js"],"sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext: { writable: true, value: null },\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: guessIndent(string) },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}