{"ast":null,"code":"import isFinite from 'lodash/isFinite';\nimport filterComponentExamples from './filterComponentExamples';\nimport filterComponentsInSectionsByExactName from './filterComponentsInSectionsByExactName';\nimport filterSectionExamples from './filterSectionExamples';\nimport findSection from './findSection';\nimport getInfoFromHash from './getInfoFromHash';\nimport { DisplayModes } from '../consts';\n/**\n * Return sections / components / examples to show on a screen according to a current route.\n *\n * Default: show all sections and components.\n * #!/Button: show only Button section or Button component\n * #!/Button/1: show only the second example (index 1) of Button component\n *\n * @param {object} sections\n * @param {string} hash\n * @param {boolean} pagePerSection\n * @returns {object}\n */\n\nexport default function getRouteData(sections, hash, pagePerSection) {\n  if (pagePerSection === void 0) {\n    pagePerSection = false;\n  } // Parse URL hash to check if the components list must be filtered\n\n\n  var infoFromHash = getInfoFromHash(hash); // Name of the filtered component/section to show isolated (/#!/Button → Button)\n\n  var targetName = infoFromHash.targetName,\n      hashArray = infoFromHash.hashArray;\n  var targetIndex = infoFromHash.targetIndex,\n      isolate = infoFromHash.isolate;\n  var displayMode = isolate ? DisplayModes.example : DisplayModes.all;\n\n  if (pagePerSection && !targetName && sections[0] && sections[0].name) {\n    // For default takes the first section when pagePerSection enabled\n    targetName = sections[0].name;\n    hashArray = [targetName];\n  }\n\n  if (targetName) {\n    var filteredSections = [];\n\n    if (pagePerSection && hashArray) {\n      // hashArray could be an array as [\"Documentation\", \"Files\", \"Button\"]\n      // each hashArray's element represent each section name with the same deep\n      // so it should be filter each section to trying to find each one of array on the same deep\n      hashArray.forEach(function (hashName, index) {\n        // Filter the requested component if required but only on the first depth\n        // so in the next time of iteration, it will be trying to filter only on the second depth and so on\n        filteredSections = filterComponentsInSectionsByExactName(sections, hashName, !!isolate); // If filteredSections exists, its because is an array of an component\n        // else it is an array of sections and depending his sectionDepth\n        // his children could be filtered or not\n\n        if (filteredSections.length) {\n          sections = filteredSections;\n        } else {\n          var section = findSection(sections, hashName);\n\n          if (section) {\n            // Only if hashName is the last of hashArray his children should be filtered\n            // because else there are possibilities to keep on filtering to try find the next section\n            var isLastHashName = !hashArray || !hashArray[index + 1]; // When sectionDepth is bigger than 0, their children should be filtered\n\n            var shouldFilterTheirChildren = (section.sectionDepth || 0) > 0 && isLastHashName;\n\n            if (shouldFilterTheirChildren) {\n              // Filter his sections and components\n              section = Object.assign({}, section, {\n                sections: [],\n                components: []\n              });\n            }\n\n            sections = [section];\n          } else {\n            sections = [];\n          }\n        }\n      });\n\n      if (!sections.length) {\n        displayMode = DisplayModes.notFound;\n      } // The targetName takes the last of hashArray\n\n\n      targetName = hashArray[hashArray.length - 1];\n    } else {\n      // Filter the requested component if required\n      filteredSections = filterComponentsInSectionsByExactName(sections, targetName, true);\n\n      if (filteredSections.length) {\n        sections = filteredSections;\n        displayMode = DisplayModes.component;\n      } else {\n        var section = findSection(sections, targetName);\n        sections = section ? [section] : [];\n        displayMode = DisplayModes.section;\n      }\n    } // If a single component or section is filtered and a fenced block index is specified hide all other examples\n\n\n    if (isFinite(targetIndex)) {\n      if (filteredSections.length === 1) {\n        var filteredComponents = filteredSections[0].components;\n        sections = [Object.assign({}, filteredSections[0], {\n          components: filteredComponents && typeof targetIndex === 'number' ? [filterComponentExamples(filteredComponents[0], targetIndex)] : []\n        })];\n        displayMode = DisplayModes.example;\n      } else if (sections.length === 1) {\n        sections = [filterSectionExamples(sections[0], targetIndex)];\n        displayMode = DisplayModes.example;\n      }\n    }\n  }\n\n  return {\n    sections: sections,\n    displayMode: displayMode\n  };\n}","map":{"version":3,"names":["isFinite","filterComponentExamples","filterComponentsInSectionsByExactName","filterSectionExamples","findSection","getInfoFromHash","DisplayModes","getRouteData","sections","hash","pagePerSection","infoFromHash","targetName","hashArray","targetIndex","isolate","displayMode","example","all","name","filteredSections","forEach","hashName","index","length","section","isLastHashName","shouldFilterTheirChildren","sectionDepth","Object","assign","components","notFound","component","filteredComponents"],"sources":["/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/react-styleguidist/lib/client/utils/getRouteData.js"],"sourcesContent":["import \"core-js/modules/es.array.for-each\";\nimport \"core-js/modules/es.function.name\";\nimport \"core-js/modules/es.object.assign\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport isFinite from 'lodash/isFinite';\nimport filterComponentExamples from './filterComponentExamples';\nimport filterComponentsInSectionsByExactName from './filterComponentsInSectionsByExactName';\nimport filterSectionExamples from './filterSectionExamples';\nimport findSection from './findSection';\nimport getInfoFromHash from './getInfoFromHash';\nimport { DisplayModes } from '../consts';\n\n/**\n * Return sections / components / examples to show on a screen according to a current route.\n *\n * Default: show all sections and components.\n * #!/Button: show only Button section or Button component\n * #!/Button/1: show only the second example (index 1) of Button component\n *\n * @param {object} sections\n * @param {string} hash\n * @param {boolean} pagePerSection\n * @returns {object}\n */\nexport default function getRouteData(sections, hash, pagePerSection) {\n  if (pagePerSection === void 0) {\n    pagePerSection = false;\n  }\n\n  // Parse URL hash to check if the components list must be filtered\n  var infoFromHash = getInfoFromHash(hash); // Name of the filtered component/section to show isolated (/#!/Button → Button)\n\n  var targetName = infoFromHash.targetName,\n      hashArray = infoFromHash.hashArray;\n  var targetIndex = infoFromHash.targetIndex,\n      isolate = infoFromHash.isolate;\n  var displayMode = isolate ? DisplayModes.example : DisplayModes.all;\n\n  if (pagePerSection && !targetName && sections[0] && sections[0].name) {\n    // For default takes the first section when pagePerSection enabled\n    targetName = sections[0].name;\n    hashArray = [targetName];\n  }\n\n  if (targetName) {\n    var filteredSections = [];\n\n    if (pagePerSection && hashArray) {\n      // hashArray could be an array as [\"Documentation\", \"Files\", \"Button\"]\n      // each hashArray's element represent each section name with the same deep\n      // so it should be filter each section to trying to find each one of array on the same deep\n      hashArray.forEach(function (hashName, index) {\n        // Filter the requested component if required but only on the first depth\n        // so in the next time of iteration, it will be trying to filter only on the second depth and so on\n        filteredSections = filterComponentsInSectionsByExactName(sections, hashName, !!isolate); // If filteredSections exists, its because is an array of an component\n        // else it is an array of sections and depending his sectionDepth\n        // his children could be filtered or not\n\n        if (filteredSections.length) {\n          sections = filteredSections;\n        } else {\n          var section = findSection(sections, hashName);\n\n          if (section) {\n            // Only if hashName is the last of hashArray his children should be filtered\n            // because else there are possibilities to keep on filtering to try find the next section\n            var isLastHashName = !hashArray || !hashArray[index + 1]; // When sectionDepth is bigger than 0, their children should be filtered\n\n            var shouldFilterTheirChildren = (section.sectionDepth || 0) > 0 && isLastHashName;\n\n            if (shouldFilterTheirChildren) {\n              // Filter his sections and components\n              section = Object.assign({}, section, {\n                sections: [],\n                components: []\n              });\n            }\n\n            sections = [section];\n          } else {\n            sections = [];\n          }\n        }\n      });\n\n      if (!sections.length) {\n        displayMode = DisplayModes.notFound;\n      } // The targetName takes the last of hashArray\n\n\n      targetName = hashArray[hashArray.length - 1];\n    } else {\n      // Filter the requested component if required\n      filteredSections = filterComponentsInSectionsByExactName(sections, targetName, true);\n\n      if (filteredSections.length) {\n        sections = filteredSections;\n        displayMode = DisplayModes.component;\n      } else {\n        var section = findSection(sections, targetName);\n        sections = section ? [section] : [];\n        displayMode = DisplayModes.section;\n      }\n    } // If a single component or section is filtered and a fenced block index is specified hide all other examples\n\n\n    if (isFinite(targetIndex)) {\n      if (filteredSections.length === 1) {\n        var filteredComponents = filteredSections[0].components;\n        sections = [Object.assign({}, filteredSections[0], {\n          components: filteredComponents && typeof targetIndex === 'number' ? [filterComponentExamples(filteredComponents[0], targetIndex)] : []\n        })];\n        displayMode = DisplayModes.example;\n      } else if (sections.length === 1) {\n        sections = [filterSectionExamples(sections[0], targetIndex)];\n        displayMode = DisplayModes.example;\n      }\n    }\n  }\n\n  return {\n    sections: sections,\n    displayMode: displayMode\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}