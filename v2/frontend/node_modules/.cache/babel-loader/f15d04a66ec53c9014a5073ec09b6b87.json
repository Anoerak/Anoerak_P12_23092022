{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* global global */\n\n\nvar KEYCODE_ENTER = 13;\nvar KEYCODE_TAB = 9;\nvar KEYCODE_BACKSPACE = 8;\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar KEYCODE_ESCAPE = 27;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\nvar isMacLike = 'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\nvar className = 'npm__react-simple-code-editor__textarea';\nvar cssText =\n/* CSS */\n'\\n/**\\n * Reset the text fill color so that placeholder is visible\\n */\\n.' + className + ':empty {\\n  -webkit-text-fill-color: inherit !important;\\n}\\n\\n/**\\n * Hack to apply on some CSS on IE10 and IE11\\n */\\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\\n  /**\\n    * IE doesn\\'t support \\'-webkit-text-fill-color\\'\\n    * So we use \\'color: transparent\\' to make the text transparent on IE\\n    * Unlike other browsers, it doesn\\'t affect caret color in IE\\n    */\\n  .' + className + ' {\\n    color: transparent !important;\\n  }\\n\\n  .' + className + '::selection {\\n    background-color: #accef7 !important;\\n    color: transparent !important;\\n  }\\n}\\n';\n\nvar Editor = function (_React$Component) {\n  _inherits(Editor, _React$Component);\n\n  function Editor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Editor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Editor.__proto__ || Object.getPrototypeOf(Editor)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      capture: true\n    }, _this._recordCurrentState = function () {\n      var input = _this._input;\n      if (!input) return; // Save current state of the input\n\n      var value = input.value,\n          selectionStart = input.selectionStart,\n          selectionEnd = input.selectionEnd;\n\n      _this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      });\n    }, _this._getLines = function (text, position) {\n      return text.substring(0, position).split('\\n');\n    }, _this._recordChange = function (record) {\n      var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _this$_history = _this._history,\n          stack = _this$_history.stack,\n          offset = _this$_history.offset;\n\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        _this._history.stack = stack.slice(0, offset + 1); // Limit the number of operations to 100\n\n        var count = _this._history.stack.length;\n\n        if (count > HISTORY_LIMIT) {\n          var extras = count - HISTORY_LIMIT;\n          _this._history.stack = stack.slice(extras, count);\n          _this._history.offset = Math.max(_this._history.offset - extras, 0);\n        }\n      }\n\n      var timestamp = Date.now();\n\n      if (overwrite) {\n        var last = _this._history.stack[_this._history.offset];\n\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n          // Match the last word in the line\n          var re = /[^a-z0-9]([a-z0-9]+)$/i; // Get the previous line\n\n          var previous = _this._getLines(last.value, last.selectionStart).pop().match(re); // Get the current line\n\n\n          var current = _this._getLines(record.value, record.selectionStart).pop().match(re);\n\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            _this._history.stack[_this._history.offset] = _extends({}, record, {\n              timestamp: timestamp\n            });\n            return;\n          }\n        }\n      } // Add the new operation to the stack\n\n\n      _this._history.stack.push(_extends({}, record, {\n        timestamp: timestamp\n      }));\n\n      _this._history.offset++;\n    }, _this._updateInput = function (record) {\n      var input = _this._input;\n      if (!input) return; // Update values and selection state\n\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n\n      _this.props.onValueChange(record.value);\n    }, _this._applyEdits = function (record) {\n      // Save last selection state\n      var input = _this._input;\n      var last = _this._history.stack[_this._history.offset];\n\n      if (last && input) {\n        _this._history.stack[_this._history.offset] = _extends({}, last, {\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd\n        });\n      } // Save the changes\n\n\n      _this._recordChange(record);\n\n      _this._updateInput(record);\n    }, _this._undoEdit = function () {\n      var _this$_history2 = _this._history,\n          stack = _this$_history2.stack,\n          offset = _this$_history2.offset; // Get the previous edit\n\n      var record = stack[offset - 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        _this._updateInput(record);\n\n        _this._history.offset = Math.max(offset - 1, 0);\n      }\n    }, _this._redoEdit = function () {\n      var _this$_history3 = _this._history,\n          stack = _this$_history3.stack,\n          offset = _this$_history3.offset; // Get the next edit\n\n      var record = stack[offset + 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        _this._updateInput(record);\n\n        _this._history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    }, _this._handleKeyDown = function (e) {\n      var _this$props = _this.props,\n          tabSize = _this$props.tabSize,\n          insertSpaces = _this$props.insertSpaces,\n          ignoreTabKey = _this$props.ignoreTabKey,\n          onKeyDown = _this$props.onKeyDown;\n\n      if (onKeyDown) {\n        onKeyDown(e);\n\n        if (e.defaultPrevented) {\n          return;\n        }\n      }\n\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        e.target.blur();\n      }\n\n      var _e$target = e.target,\n          value = _e$target.value,\n          selectionStart = _e$target.selectionStart,\n          selectionEnd = _e$target.selectionEnd;\n      var tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && _this.state.capture) {\n        // Prevent focus change\n        e.preventDefault();\n\n        if (e.shiftKey) {\n          // Unindent selected lines\n          var linesBeforeCaret = _this._getLines(value, selectionStart);\n\n          var startLine = linesBeforeCaret.length - 1;\n          var endLine = _this._getLines(value, selectionEnd).length - 1;\n          var nextValue = value.split('\\n').map(function (line, i) {\n            if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          }).join('\\n');\n\n          if (value !== nextValue) {\n            var startLineText = linesBeforeCaret[startLine];\n\n            _this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter) ? selectionStart - tabCharacter.length : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length)\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          var _linesBeforeCaret = _this._getLines(value, selectionStart);\n\n          var _startLine = _linesBeforeCaret.length - 1;\n\n          var _endLine = _this._getLines(value, selectionEnd).length - 1;\n\n          var _startLineText = _linesBeforeCaret[_startLine];\n\n          _this._applyEdits({\n            value: value.split('\\n').map(function (line, i) {\n              if (i >= _startLine && i <= _endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            }).join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(_startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (_endLine - _startLine + 1)\n          });\n        } else {\n          var updatedSelection = selectionStart + tabCharacter.length;\n\n          _this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        var hasSelection = selectionStart !== selectionEnd;\n        var textBeforeCaret = value.substring(0, selectionStart);\n\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n\n          var _updatedSelection = selectionStart - tabCharacter.length;\n\n          _this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: _updatedSelection,\n            selectionEnd: _updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          var line = _this._getLines(value, selectionStart).pop();\n\n          var matches = line.match(/^\\s+/);\n\n          if (matches && matches[0]) {\n            e.preventDefault(); // Preserve indentation on inserting a new line\n\n            var indent = '\\n' + matches[0];\n\n            var _updatedSelection2 = selectionStart + indent.length;\n\n            _this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: _updatedSelection2,\n              selectionEnd: _updatedSelection2\n            });\n          }\n        }\n      } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n        var chars = void 0;\n\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        } // If text is selected, wrap them in the characters\n\n\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n\n          _this._applyEdits({\n            value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd + 2\n          });\n        }\n      } else if ((isMacLike ? // Trigger undo with ⌘+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z : // Trigger undo with Ctrl+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n        e.preventDefault();\n\n        _this._undoEdit();\n      } else if ((isMacLike ? // Trigger redo with ⌘+Shift+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ? // Trigger redo with Ctrl+Y on Windows\n      e.ctrlKey && e.keyCode === KEYCODE_Y : // Trigger redo with Ctrl+Shift+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n        e.preventDefault();\n\n        _this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault(); // Toggle capturing tab key so users can focus away\n\n        _this.setState(function (state) {\n          return {\n            capture: !state.capture\n          };\n        });\n      }\n    }, _this._handleChange = function (e) {\n      var _e$target2 = e.target,\n          value = _e$target2.value,\n          selectionStart = _e$target2.selectionStart,\n          selectionEnd = _e$target2.selectionEnd;\n\n      _this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      }, true);\n\n      _this.props.onValueChange(value);\n    }, _this._history = {\n      stack: [],\n      offset: -1\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Editor, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this._recordCurrentState();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          value = _props.value,\n          style = _props.style,\n          padding = _props.padding,\n          highlight = _props.highlight,\n          textareaId = _props.textareaId,\n          autoFocus = _props.autoFocus,\n          disabled = _props.disabled,\n          form = _props.form,\n          maxLength = _props.maxLength,\n          minLength = _props.minLength,\n          name = _props.name,\n          placeholder = _props.placeholder,\n          readOnly = _props.readOnly,\n          required = _props.required,\n          onClick = _props.onClick,\n          onFocus = _props.onFocus,\n          onBlur = _props.onBlur,\n          onKeyUp = _props.onKeyUp,\n          onKeyDown = _props.onKeyDown,\n          onValueChange = _props.onValueChange,\n          tabSize = _props.tabSize,\n          insertSpaces = _props.insertSpaces,\n          ignoreTabKey = _props.ignoreTabKey,\n          rest = _objectWithoutProperties(_props, ['value', 'style', 'padding', 'highlight', 'textareaId', 'autoFocus', 'disabled', 'form', 'maxLength', 'minLength', 'name', 'placeholder', 'readOnly', 'required', 'onClick', 'onFocus', 'onBlur', 'onKeyUp', 'onKeyDown', 'onValueChange', 'tabSize', 'insertSpaces', 'ignoreTabKey']);\n\n      var contentStyle = {\n        paddingTop: padding,\n        paddingRight: padding,\n        paddingBottom: padding,\n        paddingLeft: padding\n      };\n      var highlighted = highlight(value);\n      return React.createElement('div', _extends({}, rest, {\n        style: _extends({}, styles.container, style)\n      }), React.createElement('textarea', {\n        ref: function ref(c) {\n          return _this2._input = c;\n        },\n        style: _extends({}, styles.editor, styles.textarea, contentStyle),\n        className: className,\n        id: textareaId,\n        value: value,\n        onChange: this._handleChange,\n        onKeyDown: this._handleKeyDown,\n        onClick: onClick,\n        onKeyUp: onKeyUp,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        disabled: disabled,\n        form: form,\n        maxLength: maxLength,\n        minLength: minLength,\n        name: name,\n        placeholder: placeholder,\n        readOnly: readOnly,\n        required: required,\n        autoFocus: autoFocus,\n        autoCapitalize: 'off',\n        autoComplete: 'off',\n        autoCorrect: 'off',\n        spellCheck: false,\n        'data-gramm': false\n      }), React.createElement('pre', _extends({\n        'aria-hidden': 'true',\n        style: _extends({}, styles.editor, styles.highlight, contentStyle)\n      }, typeof highlighted === 'string' ? {\n        dangerouslySetInnerHTML: {\n          __html: highlighted + '<br />'\n        }\n      } : {\n        children: highlighted\n      })), React.createElement('style', {\n        type: 'text/css',\n        dangerouslySetInnerHTML: {\n          __html: cssText\n        }\n      }));\n    }\n  }, {\n    key: 'session',\n    get: function get() {\n      return {\n        history: this._history\n      };\n    },\n    set: function set(session) {\n      this._history = session.history;\n    }\n  }]);\n\n  return Editor;\n}(React.Component);\n\nEditor.defaultProps = {\n  tabSize: 2,\n  insertSpaces: true,\n  ignoreTabKey: false,\n  padding: 0\n};\nexports.default = Editor;\nvar styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden'\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent'\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none'\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word'\n  }\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;IAAYA,K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFZ;;;AAgDA,IAAMC,gBAAgB,EAAtB;AACA,IAAMC,cAAc,CAApB;AACA,IAAMC,oBAAoB,CAA1B;AACA,IAAMC,YAAY,EAAlB;AACA,IAAMC,YAAY,EAAlB;AACA,IAAMC,YAAY,EAAlB;AACA,IAAMC,iBAAiB,EAAvB;AACA,IAAMC,mBAAmB,GAAzB;AACA,IAAMC,gBAAgB,GAAtB;AACA,IAAMC,qBAAqB,GAA3B;AACA,IAAMC,iBAAiB,EAAvB;AAEA,IAAMC,gBAAgB,GAAtB;AACA,IAAMC,mBAAmB,IAAzB;AAEA,IAAMC,YAAY,eAAeC,MAAf,IAAyB,OAAOC,IAAP,CAAYC,UAAUC,QAAtB,CAA3C;AACA,IAAMC,YACJ,eAAeJ,MAAf,IAAyB,0BAA0BC,IAA1B,CAA+BC,UAAUC,QAAzC,CAD3B;AAGA,IAAME,YAAY,yCAAlB;AAEA,IAAMC;AAAU;AAAV,+EAIHD,SAJG,gaAiBDA,SAjBC,0DAqBDA,SArBC,2GAAN;;IA4BqBE,M;;;;;;;;;;;;;;sLAQnBC,QAAQ;MACNC,SAAS;IADH,G,MAQRC,mB,GAAsB,YAAM;MAC1B,IAAMC,QAAQC,MAAKC,MAAnB;MAEA,IAAI,CAACF,KAAL,EAAY,OAHc,CAK1B;;MAL0B,IAMlBG,KANkB,GAMsBH,KANtB,CAMlBG,KANkB;MAAA,IAMXC,cANW,GAMsBJ,KANtB,CAMXI,cANW;MAAA,IAMKC,YANL,GAMsBL,KANtB,CAMKK,YANL;;MAQ1BJ,MAAKK,aAAL,CAAmB;QACjBH,YADiB;QAEjBC,8BAFiB;QAGjBC;MAHiB,CAAnB;aAOFE,S,GAAY,UAACC,IAAD,EAAeC,QAAf;MAAA,OACVD,KAAKE,SAALF,CAAe,CAAfA,EAAkBC,QAAlBD,EAA4BG,KAA5BH,CAAkC,IAAlCA,CADU;aAGZF,a,GAAgB,UAACM,MAAD,EAAiD;MAAA,IAAhCC,SAAgC,uEAAV,KAAU;MAAA,qBACrCZ,MAAKa,QADgC;MAAA,IACvDC,KADuD,kBACvDA,KADuD;MAAA,IAChDC,MADgD,kBAChDA,MADgD;;MAG/D,IAAID,MAAME,MAANF,IAAgBC,SAAS,CAAC,CAA9B,EAAiC;QAC/B;QACAf,MAAKa,QAAL,CAAcC,KAAd,GAAsBA,MAAMG,KAANH,CAAY,CAAZA,EAAeC,SAAS,CAAxBD,CAAtB,CAF+B,CAI/B;;QACA,IAAMI,QAAQlB,MAAKa,QAAL,CAAcC,KAAd,CAAoBE,MAAlC;;QAEA,IAAIE,QAAQjC,aAAZ,EAA2B;UACzB,IAAMkC,SAASD,QAAQjC,aAAvB;UAEAe,MAAKa,QAAL,CAAcC,KAAd,GAAsBA,MAAMG,KAANH,CAAYK,MAAZL,EAAoBI,KAApBJ,CAAtB;UACAd,MAAKa,QAAL,CAAcE,MAAd,GAAuBK,KAAKC,GAALD,CAASpB,MAAKa,QAAL,CAAcE,MAAd,GAAuBI,MAAhCC,EAAwC,CAAxCA,CAAvB;QACD;MACF;;MAED,IAAME,YAAYC,KAAKC,GAALD,EAAlB;;MAEA,IAAIX,SAAJ,EAAe;QACb,IAAMa,OAAOzB,MAAKa,QAAL,CAAcC,KAAd,CAAoBd,MAAKa,QAAL,CAAcE,MAAlC,CAAb;;QAEA,IAAIU,QAAQH,YAAYG,KAAKH,SAAjBA,GAA6BpC,gBAAzC,EAA2D;UACzD;UAEA;UACA,IAAMwC,KAAK,wBAAX,CAJyD,CAMzD;;UACA,IAAMC,WAAW3B,MAAKM,SAAL,CAAemB,KAAKvB,KAApB,EAA2BuB,KAAKtB,cAAhC,EACdyB,GADc,GAEdC,KAFc,CAERH,EAFQ,CAAjB,CAPyD,CAWzD;;;UACA,IAAMI,UAAU9B,MAAKM,SAAL,CAAeK,OAAOT,KAAtB,EAA6BS,OAAOR,cAApC,EACbyB,GADa,GAEbC,KAFa,CAEPH,EAFO,CAAhB;;UAIA,IAAIC,YAAYG,OAAZH,IAAuBG,QAAQ,CAARA,EAAWC,UAAXD,CAAsBH,SAAS,CAATA,CAAtBG,CAA3B,EAA+D;YAC7D;YACA;YACA9B,MAAKa,QAAL,CAAcC,KAAd,CAAoBd,MAAKa,QAAL,CAAcE,MAAlC,iBAAiDJ,MAAjD;cAAyDW;YAAzD;YAEA;UACD;QACF;MACF,CA/C8D,CAiD/D;;;MACAtB,MAAKa,QAAL,CAAcC,KAAd,CAAoBkB,IAApB,cAA8BrB,MAA9B;QAAsCW;MAAtC;;MACAtB,MAAKa,QAAL,CAAcE,MAAd;aAGFkB,Y,GAAe,UAACtB,MAAD,EAAoB;MACjC,IAAMZ,QAAQC,MAAKC,MAAnB;MAEA,IAAI,CAACF,KAAL,EAAY,OAHqB,CAKjC;;MACAA,MAAMG,KAANH,GAAcY,OAAOT,KAArBH;MACAA,MAAMI,cAANJ,GAAuBY,OAAOR,cAA9BJ;MACAA,MAAMK,YAANL,GAAqBY,OAAOP,YAA5BL;;MAEAC,MAAKkC,KAAL,CAAWC,aAAX,CAAyBxB,OAAOT,KAAhC;aAGFkC,W,GAAc,UAACzB,MAAD,EAAoB;MAChC;MACA,IAAMZ,QAAQC,MAAKC,MAAnB;MACA,IAAMwB,OAAOzB,MAAKa,QAAL,CAAcC,KAAd,CAAoBd,MAAKa,QAAL,CAAcE,MAAlC,CAAb;;MAEA,IAAIU,QAAQ1B,KAAZ,EAAmB;QACjBC,MAAKa,QAAL,CAAcC,KAAd,CAAoBd,MAAKa,QAAL,CAAcE,MAAlC,iBACKU,IADL;UAEEtB,gBAAgBJ,MAAMI,cAFxB;UAGEC,cAAcL,MAAMK;QAHtB;MAKD,CAX+B,CAahC;;;MACAJ,MAAKK,aAAL,CAAmBM,MAAnB;;MACAX,MAAKiC,YAAL,CAAkBtB,MAAlB;aAGF0B,S,GAAY,YAAM;MAAA,sBACUrC,MAAKa,QADf;MAAA,IACRC,KADQ,mBACRA,KADQ;MAAA,IACDC,MADC,mBACDA,MADC,EAGhB;;MACA,IAAMJ,SAASG,MAAMC,SAAS,CAAfD,CAAf;;MAEA,IAAIH,MAAJ,EAAY;QACV;QACAX,MAAKiC,YAAL,CAAkBtB,MAAlB;;QACAX,MAAKa,QAAL,CAAcE,MAAd,GAAuBK,KAAKC,GAALD,CAASL,SAAS,CAAlBK,EAAqB,CAArBA,CAAvB;MACD;aAGHkB,S,GAAY,YAAM;MAAA,sBACUtC,MAAKa,QADf;MAAA,IACRC,KADQ,mBACRA,KADQ;MAAA,IACDC,MADC,mBACDA,MADC,EAGhB;;MACA,IAAMJ,SAASG,MAAMC,SAAS,CAAfD,CAAf;;MAEA,IAAIH,MAAJ,EAAY;QACV;QACAX,MAAKiC,YAAL,CAAkBtB,MAAlB;;QACAX,MAAKa,QAAL,CAAcE,MAAd,GAAuBK,KAAKmB,GAALnB,CAASL,SAAS,CAAlBK,EAAqBN,MAAME,MAANF,GAAe,CAApCM,CAAvB;MACD;aAGHoB,c,GAAiB,UAACC,CAAD,EAAU;MAAA,kBACkCzC,MAAKkC,KADvC;MAAA,IACjBQ,OADiB,eACjBA,OADiB;MAAA,IACRC,YADQ,eACRA,YADQ;MAAA,IACMC,YADN,eACMA,YADN;MAAA,IACoBC,SADpB,eACoBA,SADpB;;MAGzB,IAAIA,SAAJ,EAAe;QACbA,UAAUJ,CAAVI;;QAEA,IAAIJ,EAAEK,gBAAN,EAAwB;UACtB;QACD;MACF;;MAED,IAAIL,EAAEM,OAAFN,KAAczD,cAAlB,EAAkC;QAChCyD,EAAEO,MAAFP,CAASQ,IAATR;MACD;;MAbwB,gBAeuBA,EAAEO,MAfzB;MAAA,IAejB9C,KAfiB,aAejBA,KAfiB;MAAA,IAeVC,cAfU,aAeVA,cAfU;MAAA,IAeMC,YAfN,aAeMA,YAfN;MAiBzB,IAAM8C,eAAe,CAACP,eAAe,GAAfA,GAAqB,IAAtB,EAA4BQ,MAA5B,CAAmCT,OAAnC,CAArB;;MAEA,IAAID,EAAEM,OAAFN,KAAclE,WAAdkE,IAA6B,CAACG,YAA9BH,IAA8CzC,MAAKJ,KAAL,CAAWC,OAA7D,EAAsE;QACpE;QACA4C,EAAEW,cAAFX;;QAEA,IAAIA,EAAEY,QAAN,EAAgB;UACd;UACA,IAAMC,mBAAmBtD,MAAKM,SAAL,CAAeJ,KAAf,EAAsBC,cAAtB,CAAzB;;UACA,IAAMoD,YAAYD,iBAAiBtC,MAAjBsC,GAA0B,CAA5C;UACA,IAAME,UAAUxD,MAAKM,SAAL,CAAeJ,KAAf,EAAsBE,YAAtB,EAAoCY,MAApC,GAA6C,CAA7D;UACA,IAAMyC,YAAYvD,MACfQ,KADeR,CACT,IADSA,EAEfwD,GAFexD,CAEX,UAACyD,IAAD,EAAOC,CAAP,EAAa;YAChB,IACEA,KAAKL,SAALK,IACAA,KAAKJ,OADLI,IAEAD,KAAK5B,UAAL4B,CAAgBT,YAAhBS,CAHF,EAIE;cACA,OAAOA,KAAKlD,SAALkD,CAAeT,aAAalC,MAA5B2C,CAAP;YACD;;YAED,OAAOA,IAAP;UAXc,GAafE,IAbe3D,CAaV,IAbUA,CAAlB;;UAeA,IAAIA,UAAUuD,SAAd,EAAyB;YACvB,IAAMK,gBAAgBR,iBAAiBC,SAAjBD,CAAtB;;YAEAtD,MAAKoC,WAAL,CAAiB;cACflC,OAAOuD,SADQ;cAEf;cACA;cACAtD,gBAAgB2D,cAAc/B,UAAd+B,CAAyBZ,YAAzBY,IACZ3D,iBAAiB+C,aAAalC,MADlB8C,GAEZ3D,cANW;cAOf;cACAC,cAAcA,gBAAgBF,MAAMc,MAANd,GAAeuD,UAAUzC,MAAzCZ;YARC,CAAjB;UAUD;QAjCH,OAkCO,IAAID,mBAAmBC,YAAvB,EAAqC;UAC1C;UACA,IAAMkD,oBAAmBtD,MAAKM,SAAL,CAAeJ,KAAf,EAAsBC,cAAtB,CAAzB;;UACA,IAAMoD,aAAYD,kBAAiBtC,MAAjBsC,GAA0B,CAA5C;;UACA,IAAME,WAAUxD,MAAKM,SAAL,CAAeJ,KAAf,EAAsBE,YAAtB,EAAoCY,MAApC,GAA6C,CAA7D;;UACA,IAAM8C,iBAAgBR,kBAAiBC,UAAjBD,CAAtB;;UAEAtD,MAAKoC,WAAL,CAAiB;YACflC,OAAOA,MACJQ,KADIR,CACE,IADFA,EAEJwD,GAFIxD,CAEA,UAACyD,IAAD,EAAOC,CAAP,EAAa;cAChB,IAAIA,KAAKL,UAALK,IAAkBA,KAAKJ,QAA3B,EAAoC;gBAClC,OAAON,eAAeS,IAAtB;cACD;;cAED,OAAOA,IAAP;YAPG,GASJE,IATI3D,CASC,IATDA,CADQ;YAWf;YACA;YACAC,gBAAgB,KAAKd,IAAL,CAAUyE,cAAV,IACZ3D,iBAAiB+C,aAAalC,MADlB,GAEZb,cAfW;YAgBf;YACAC,cACEA,eAAe8C,aAAalC,MAAbkC,IAAuBM,WAAUD,UAAVC,GAAsB,CAA7CN;UAlBF,CAAjB;QAPK,OA2BA;UACL,IAAMa,mBAAmB5D,iBAAiB+C,aAAalC,MAAvD;;UAEAhB,MAAKoC,WAAL,CAAiB;YACf;YACAlC,OACEA,MAAMO,SAANP,CAAgB,CAAhBA,EAAmBC,cAAnBD,IACAgD,YADAhD,GAEAA,MAAMO,SAANP,CAAgBE,YAAhBF,CALa;YAMf;YACAC,gBAAgB4D,gBAPD;YAQf3D,cAAc2D;UARC,CAAjB;QAUD;MA9EH,OA+EO,IAAItB,EAAEM,OAAFN,KAAcjE,iBAAlB,EAAqC;QAC1C,IAAMwF,eAAe7D,mBAAmBC,YAAxC;QACA,IAAM6D,kBAAkB/D,MAAMO,SAANP,CAAgB,CAAhBA,EAAmBC,cAAnBD,CAAxB;;QAEA,IAAI+D,gBAAgBC,QAAhBD,CAAyBf,YAAzBe,KAA0C,CAACD,YAA/C,EAA6D;UAC3D;UACAvB,EAAEW,cAAFX;;UAEA,IAAMsB,oBAAmB5D,iBAAiB+C,aAAalC,MAAvD;;UAEAhB,MAAKoC,WAAL,CAAiB;YACf;YACAlC,OACEA,MAAMO,SAANP,CAAgB,CAAhBA,EAAmBC,iBAAiB+C,aAAalC,MAAjDd,IACAA,MAAMO,SAANP,CAAgBE,YAAhBF,CAJa;YAKf;YACAC,gBAAgB4D,iBAND;YAOf3D,cAAc2D;UAPC,CAAjB;QASD;MAnBI,OAoBA,IAAItB,EAAEM,OAAFN,KAAcnE,aAAlB,EAAiC;QACtC;QACA,IAAI6B,mBAAmBC,YAAvB,EAAqC;UACnC;UACA,IAAMuD,OAAO3D,MAAKM,SAAL,CAAeJ,KAAf,EAAsBC,cAAtB,EAAsCyB,GAAtC,EAAb;;UACA,IAAMuC,UAAUR,KAAK9B,KAAL8B,CAAW,MAAXA,CAAhB;;UAEA,IAAIQ,WAAWA,QAAQ,CAARA,CAAf,EAA2B;YACzB1B,EAAEW,cAAFX,GADyB,CAGzB;;YACA,IAAM2B,SAAS,OAAOD,QAAQ,CAARA,CAAtB;;YACA,IAAMJ,qBAAmB5D,iBAAiBiE,OAAOpD,MAAjD;;YAEAhB,MAAKoC,WAAL,CAAiB;cACf;cACAlC,OACEA,MAAMO,SAANP,CAAgB,CAAhBA,EAAmBC,cAAnBD,IACAkE,MADAlE,GAEAA,MAAMO,SAANP,CAAgBE,YAAhBF,CALa;cAMf;cACAC,gBAAgB4D,kBAPD;cAQf3D,cAAc2D;YARC,CAAjB;UAUD;QACF;MAzBI,OA0BA,IACLtB,EAAEM,OAAFN,KAAc7D,cAAd6D,IACAA,EAAEM,OAAFN,KAAc5D,gBADd4D,IAEAA,EAAEM,OAAFN,KAAc3D,aAFd2D,IAGAA,EAAEM,OAAFN,KAAc1D,kBAJT,EAKL;QACA,IAAIsF,cAAJ;;QAEA,IAAI5B,EAAEM,OAAFN,KAAc7D,cAAd6D,IAAgCA,EAAEY,QAAtC,EAAgD;UAC9CgB,QAAQ,CAAC,GAAD,EAAM,GAAN,CAARA;QADF,OAEO,IAAI5B,EAAEM,OAAFN,KAAc5D,gBAAlB,EAAoC;UACzC,IAAI4D,EAAEY,QAAN,EAAgB;YACdgB,QAAQ,CAAC,GAAD,EAAM,GAAN,CAARA;UADF,OAEO;YACLA,QAAQ,CAAC,GAAD,EAAM,GAAN,CAARA;UACD;QALI,OAMA,IAAI5B,EAAEM,OAAFN,KAAc3D,aAAlB,EAAiC;UACtC,IAAI2D,EAAEY,QAAN,EAAgB;YACdgB,QAAQ,CAAC,GAAD,EAAM,GAAN,CAARA;UADF,OAEO;YACLA,QAAQ,CAAC,GAAD,EAAM,GAAN,CAARA;UACD;QALI,OAMA,IAAI5B,EAAEM,OAAFN,KAAc1D,kBAAd0D,IAAoC,CAACA,EAAEY,QAA3C,EAAqD;UAC1DgB,QAAQ,CAAC,GAAD,EAAM,GAAN,CAARA;QACD,CAnBD,CAqBA;;;QACA,IAAIlE,mBAAmBC,YAAnBD,IAAmCkE,KAAvC,EAA8C;UAC5C5B,EAAEW,cAAFX;;UAEAzC,MAAKoC,WAAL,CAAiB;YACflC,OACEA,MAAMO,SAANP,CAAgB,CAAhBA,EAAmBC,cAAnBD,IACAmE,MAAM,CAANA,CADAnE,GAEAA,MAAMO,SAANP,CAAgBC,cAAhBD,EAAgCE,YAAhCF,CAFAA,GAGAmE,MAAM,CAANA,CAHAnE,GAIAA,MAAMO,SAANP,CAAgBE,YAAhBF,CANa;YAOf;YACAC,8BARe;YASfC,cAAcA,eAAe;UATd,CAAjB;QAWD;MAzCI,OA0CA,IACL,CAACZ,YACG;MACAiD,EAAE6B,OAAF7B,IAAaA,EAAEM,OAAFN,KAAc/D,SAF9Bc,GAGG;MACAiD,EAAE8B,OAAF9B,IAAaA,EAAEM,OAAFN,KAAc/D,SAJ/B,KAKA,CAAC+D,EAAEY,QALH,IAMA,CAACZ,EAAE+B,MAPE,EAQL;QACA/B,EAAEW,cAAFX;;QAEAzC,MAAKqC,SAAL;MAXK,OAYA,IACL,CAAC7C,YACG;MACAiD,EAAE6B,OAAF7B,IAAaA,EAAEM,OAAFN,KAAc/D,SAA3B+D,IAAwCA,EAAEY,QAF7C7D,GAGGL,YACE;MACAsD,EAAE8B,OAAF9B,IAAaA,EAAEM,OAAFN,KAAchE,SAF7BU,GAGE;MACAsD,EAAE8B,OAAF9B,IAAaA,EAAEM,OAAFN,KAAc/D,SAA3B+D,IAAwCA,EAAEY,QAPhD,KAQA,CAACZ,EAAE+B,MATE,EAUL;QACA/B,EAAEW,cAAFX;;QAEAzC,MAAKsC,SAAL;MAbK,OAcA,IACLG,EAAEM,OAAFN,KAAc9D,SAAd8D,IACAA,EAAE8B,OADF9B,KAECjD,YAAYiD,EAAEY,QAAd7D,GAAyB,IAF1BiD,CADK,EAIL;QACAA,EAAEW,cAAFX,GADA,CAGA;;QACAzC,MAAKyE,QAAL,CAAc;UAAA,OAAU;YACtB5E,SAAS,CAACD,MAAMC;UADM,CAAV;QAAd;MAGD;aAGH6E,a,GAAgB,UAACjC,CAAD,EAAU;MAAA,iBACwBA,EAAEO,MAD1B;MAAA,IAChB9C,KADgB,cAChBA,KADgB;MAAA,IACTC,cADS,cACTA,cADS;MAAA,IACOC,YADP,cACOA,YADP;;MAGxBJ,MAAKK,aAAL,CACE;QACEH,YADF;QAEEC,8BAFF;QAGEC;MAHF,CADF,EAME,IANF;;MASAJ,MAAKkC,KAAL,CAAWC,aAAX,CAAyBjC,KAAzB;aAGFW,Q,GAAoB;MAClBC,OAAO,EADW;MAElBC,QAAQ,CAAC;IAFS,G;;;;;wCAtXA;MAClB,KAAKjB,mBAAL;IACD;;;6BAqYQ;MAAA;;MAAA,aA4BH,KAAKoC,KA5BF;MAAA,IAELhC,KAFK,UAELA,KAFK;MAAA,IAGLyE,KAHK,UAGLA,KAHK;MAAA,IAILC,OAJK,UAILA,OAJK;MAAA,IAKLC,SALK,UAKLA,SALK;MAAA,IAMLC,UANK,UAMLA,UANK;MAAA,IAOLC,SAPK,UAOLA,SAPK;MAAA,IAQLC,QARK,UAQLA,QARK;MAAA,IASLC,IATK,UASLA,IATK;MAAA,IAULC,SAVK,UAULA,SAVK;MAAA,IAWLC,SAXK,UAWLA,SAXK;MAAA,IAYLC,IAZK,UAYLA,IAZK;MAAA,IAaLC,WAbK,UAaLA,WAbK;MAAA,IAcLC,QAdK,UAcLA,QAdK;MAAA,IAeLC,QAfK,UAeLA,QAfK;MAAA,IAgBLC,OAhBK,UAgBLA,OAhBK;MAAA,IAiBLC,OAjBK,UAiBLA,OAjBK;MAAA,IAkBLC,MAlBK,UAkBLA,MAlBK;MAAA,IAmBLC,OAnBK,UAmBLA,OAnBK;MAAA,IAqBL9C,SArBK,UAqBLA,SArBK;MAAA,IAsBLV,aAtBK,UAsBLA,aAtBK;MAAA,IAuBLO,OAvBK,UAuBLA,OAvBK;MAAA,IAwBLC,YAxBK,UAwBLA,YAxBK;MAAA,IAyBLC,YAzBK,UAyBLA,YAzBK;MAAA,IA2BFgD,IA3BE;;MA8BP,IAAMC,eAAe;QACnBC,YAAYlB,OADO;QAEnBmB,cAAcnB,OAFK;QAGnBoB,eAAepB,OAHI;QAInBqB,aAAarB;MAJM,CAArB;MAOA,IAAMsB,cAAcrB,UAAU3E,KAAV2E,CAApB;MAEA,OACExG,wCAASuH,IAAT;QAAejB,oBAAYwB,OAAOC,SAAnB,EAAiCzB,KAAjC;MAAf,IACEtG;QACEgI,KAAK;UAAA,OAAMC,OAAKrG,MAAL,GAAcsG,CAApB;QADP;QAEE5B,oBACKwB,OAAOK,MADZ,EAEKL,OAAOM,QAFZ,EAGKZ,YAHL,CAFF;QAOEpG,WAAWA,SAPb;QAQEiH,IAAI5B,UARN;QASE5E,OAAOA,KATT;QAUEyG,UAAU,KAAKjC,aAVjB;QAWE7B,WAAW,KAAKL,cAXlB;QAYEgD,SAASA,OAZX;QAaEG,SAASA,OAbX;QAcEF,SAASA,OAdX;QAeEC,QAAQA,MAfV;QAgBEV,UAAUA,QAhBZ;QAiBEC,MAAMA,IAjBR;QAkBEC,WAAWA,SAlBb;QAmBEC,WAAWA,SAnBb;QAoBEC,MAAMA,IApBR;QAqBEC,aAAaA,WArBf;QAsBEC,UAAUA,QAtBZ;QAuBEC,UAAUA,QAvBZ;QAwBER,WAAWA,SAxBb;QAyBE6B,gBAAe,KAzBjB;QA0BEC,cAAa,KA1Bf;QA2BEC,aAAY,KA3Bd;QA4BEC,YAAY,KA5Bd;QA6BE,cAAY;MA7Bd,EADF,EAgCE1I;QACE,eAAY,MADd;QAEEsG,oBAAYwB,OAAOK,MAAnB,EAA8BL,OAAOtB,SAArC,EAAmDgB,YAAnD;MAFF,GAGO,OAAOK,WAAP,KAAuB,QAAvB,GACD;QAAEc,yBAAyB;UAAEC,QAAQf,cAAc;QAAxB;MAA3B,CADC,GAED;QAAEgB,UAAUhB;MAAZ,CALN,EAhCF,EAwCE7H;QAAO8I,MAAK,UAAZ;QAAuBH,yBAAyB;UAAEC,QAAQvH;QAAV;MAAhD,EAxCF,CADF;IA4CD;;;wBA7Fa;MACZ,OAAO;QACL0H,SAAS,KAAKvG;MADT,CAAP;;sBAKUwG,SAA+B;MACzC,KAAKxG,QAAL,GAAgBwG,QAAQD,OAAxB;IACD;;;;EAjZiC/I,MAAMiJ,S;;AAArB3H,M,CACZ4H,YADY5H,GACG;EACpB+C,SAAS,CADW;EAEpBC,cAAc,IAFM;EAGpBC,cAAc,KAHM;EAIpBgC,SAAS;AAJW,CADHjF;kBAAAA;AAyerB,IAAMwG,SAAS;EACbC,WAAW;IACT5F,UAAU,UADD;IAETgH,WAAW,MAFF;IAGTC,WAAW,YAHF;IAIT7C,SAAS,CAJA;IAKT8C,UAAU;EALD,CADE;EAQbjB,UAAU;IACRjG,UAAU,UADF;IAERmH,KAAK,CAFG;IAGRC,MAAM,CAHE;IAIRC,QAAQ,MAJA;IAKRC,OAAO,MALC;IAMRC,QAAQ,MANA;IAORC,OAAO,SAPC;IAQRN,UAAU,QARF;IASRO,qBAAqB,WATb;IAURC,qBAAqB,aAVb;IAWRC,qBAAqB;EAXb,CARG;EAqBbtD,WAAW;IACTrE,UAAU,UADD;IAET4H,eAAe;EAFN,CArBE;EAyBb5B,QAAQ;IACN6B,QAAQ,CADF;IAENC,QAAQ,CAFF;IAGNC,YAAY,MAHN;IAINd,WAAW,SAJL;IAKNe,SAAS,SALH;IAMNC,YAAY,SANN;IAONC,UAAU,SAPJ;IAQNC,WAAW,SARL;IASNC,sBAAsB,SAThB;IAUNC,YAAY,SAVN;IAWNC,eAAe,SAXT;IAYNC,YAAY,SAZN;IAaNrG,SAAS,SAbH;IAcNsG,YAAY,SAdN;IAeNC,eAAe,SAfT;IAgBNC,eAAe,SAhBT;IAiBNC,YAAY,UAjBN;IAkBNC,WAAW,UAlBL;IAmBNC,cAAc;EAnBR;AAzBK,CAAf","names":["React","KEYCODE_ENTER","KEYCODE_TAB","KEYCODE_BACKSPACE","KEYCODE_Y","KEYCODE_Z","KEYCODE_M","KEYCODE_PARENS","KEYCODE_BRACKETS","KEYCODE_QUOTE","KEYCODE_BACK_QUOTE","KEYCODE_ESCAPE","HISTORY_LIMIT","HISTORY_TIME_GAP","isWindows","global","test","navigator","platform","isMacLike","className","cssText","Editor","state","capture","_recordCurrentState","input","_this","_input","value","selectionStart","selectionEnd","_recordChange","_getLines","text","position","substring","split","record","overwrite","_history","stack","offset","length","slice","count","extras","Math","max","timestamp","Date","now","last","re","previous","pop","match","current","startsWith","push","_updateInput","props","onValueChange","_applyEdits","_undoEdit","_redoEdit","min","_handleKeyDown","e","tabSize","insertSpaces","ignoreTabKey","onKeyDown","defaultPrevented","keyCode","target","blur","tabCharacter","repeat","preventDefault","shiftKey","linesBeforeCaret","startLine","endLine","nextValue","map","line","i","join","startLineText","updatedSelection","hasSelection","textBeforeCaret","endsWith","matches","indent","chars","metaKey","ctrlKey","altKey","setState","_handleChange","style","padding","highlight","textareaId","autoFocus","disabled","form","maxLength","minLength","name","placeholder","readOnly","required","onClick","onFocus","onBlur","onKeyUp","rest","contentStyle","paddingTop","paddingRight","paddingBottom","paddingLeft","highlighted","styles","container","ref","_this2","c","editor","textarea","id","onChange","autoCapitalize","autoComplete","autoCorrect","spellCheck","dangerouslySetInnerHTML","__html","children","type","history","session","Component","defaultProps","textAlign","boxSizing","overflow","top","left","height","width","resize","color","MozOsxFontSmoothing","WebkitFontSmoothing","WebkitTextFillColor","pointerEvents","margin","border","background","display","fontFamily","fontSize","fontStyle","fontVariantLigatures","fontWeight","letterSpacing","lineHeight","textIndent","textRendering","textTransform","whiteSpace","wordBreak","overflowWrap"],"sources":["/Users/sebastien/Sebbe's Cloud/School/OpenClassRooms/2 - OCR - Software Developper - JS & React/Projet 12 (60h)/P12 - Mission/0Code/frontend/node_modules/react-styleguidist/node_modules/react-simple-code-editor/src/index.js"],"sourcesContent":["/* @flow */\n/* global global */\n\nimport * as React from 'react';\n\ntype Props = React.ElementConfig<'div'> & {\n  // Props for the component\n  value: string,\n  onValueChange: (value: string) => mixed,\n  highlight: (value: string) => string | React.Node,\n  tabSize: number,\n  insertSpaces: boolean,\n  ignoreTabKey: boolean,\n  padding: number | string,\n  style?: {},\n\n  // Props for the textarea\n  textareaId?: string,\n  autoFocus?: boolean,\n  disabled?: boolean,\n  form?: string,\n  maxLength?: number,\n  minLength?: number,\n  name?: string,\n  placeholder?: string,\n  readOnly?: boolean,\n  required?: boolean,\n  onClick?: (e: MouseEvent) => mixed,\n  onFocus?: (e: FocusEvent) => mixed,\n  onBlur?: (e: FocusEvent) => mixed,\n  onKeyUp?: (e: KeyboardEvent) => mixed,\n  onKeyDown?: (e: KeyboardEvent) => mixed,\n};\n\ntype State = {\n  capture: boolean,\n};\n\ntype Record = {\n  value: string,\n  selectionStart: number,\n  selectionEnd: number,\n};\n\ntype History = {\n  stack: Array<Record & { timestamp: number }>,\n  offset: number,\n};\n\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\nconst isMacLike =\n  'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nconst className = 'npm__react-simple-code-editor__textarea';\n\nconst cssText = /* CSS */ `\n/**\n * Reset the text fill color so that placeholder is visible\n */\n.${className}:empty {\n  -webkit-text-fill-color: inherit !important;\n}\n\n/**\n * Hack to apply on some CSS on IE10 and IE11\n */\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\n  /**\n    * IE doesn't support '-webkit-text-fill-color'\n    * So we use 'color: transparent' to make the text transparent on IE\n    * Unlike other browsers, it doesn't affect caret color in IE\n    */\n  .${className} {\n    color: transparent !important;\n  }\n\n  .${className}::selection {\n    background-color: #accef7 !important;\n    color: transparent !important;\n  }\n}\n`;\n\nexport default class Editor extends React.Component<Props, State> {\n  static defaultProps = {\n    tabSize: 2,\n    insertSpaces: true,\n    ignoreTabKey: false,\n    padding: 0,\n  };\n\n  state = {\n    capture: true,\n  };\n\n  componentDidMount() {\n    this._recordCurrentState();\n  }\n\n  _recordCurrentState = () => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Save current state of the input\n    const { value, selectionStart, selectionEnd } = input;\n\n    this._recordChange({\n      value,\n      selectionStart,\n      selectionEnd,\n    });\n  };\n\n  _getLines = (text: string, position: number) =>\n    text.substring(0, position).split('\\n');\n\n  _recordChange = (record: Record, overwrite?: boolean = false) => {\n    const { stack, offset } = this._history;\n\n    if (stack.length && offset > -1) {\n      // When something updates, drop the redo operations\n      this._history.stack = stack.slice(0, offset + 1);\n\n      // Limit the number of operations to 100\n      const count = this._history.stack.length;\n\n      if (count > HISTORY_LIMIT) {\n        const extras = count - HISTORY_LIMIT;\n\n        this._history.stack = stack.slice(extras, count);\n        this._history.offset = Math.max(this._history.offset - extras, 0);\n      }\n    }\n\n    const timestamp = Date.now();\n\n    if (overwrite) {\n      const last = this._history.stack[this._history.offset];\n\n      if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n        // A previous entry exists and was in short interval\n\n        // Match the last word in the line\n        const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n        // Get the previous line\n        const previous = this._getLines(last.value, last.selectionStart)\n          .pop()\n          .match(re);\n\n        // Get the current line\n        const current = this._getLines(record.value, record.selectionStart)\n          .pop()\n          .match(re);\n\n        if (previous && current && current[1].startsWith(previous[1])) {\n          // The last word of the previous line and current line match\n          // Overwrite previous entry so that undo will remove whole word\n          this._history.stack[this._history.offset] = { ...record, timestamp };\n\n          return;\n        }\n      }\n    }\n\n    // Add the new operation to the stack\n    this._history.stack.push({ ...record, timestamp });\n    this._history.offset++;\n  };\n\n  _updateInput = (record: Record) => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Update values and selection state\n    input.value = record.value;\n    input.selectionStart = record.selectionStart;\n    input.selectionEnd = record.selectionEnd;\n\n    this.props.onValueChange(record.value);\n  };\n\n  _applyEdits = (record: Record) => {\n    // Save last selection state\n    const input = this._input;\n    const last = this._history.stack[this._history.offset];\n\n    if (last && input) {\n      this._history.stack[this._history.offset] = {\n        ...last,\n        selectionStart: input.selectionStart,\n        selectionEnd: input.selectionEnd,\n      };\n    }\n\n    // Save the changes\n    this._recordChange(record);\n    this._updateInput(record);\n  };\n\n  _undoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the previous edit\n    const record = stack[offset - 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.max(offset - 1, 0);\n    }\n  };\n\n  _redoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the next edit\n    const record = stack[offset + 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.min(offset + 1, stack.length - 1);\n    }\n  };\n\n  _handleKeyDown = (e: *) => {\n    const { tabSize, insertSpaces, ignoreTabKey, onKeyDown } = this.props;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n\n      if (e.defaultPrevented) {\n        return;\n      }\n    }\n\n    if (e.keyCode === KEYCODE_ESCAPE) {\n      e.target.blur();\n    }\n\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n    if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.state.capture) {\n      // Prevent focus change\n      e.preventDefault();\n\n      if (e.shiftKey) {\n        // Unindent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const nextValue = value\n          .split('\\n')\n          .map((line, i) => {\n            if (\n              i >= startLine &&\n              i <= endLine &&\n              line.startsWith(tabCharacter)\n            ) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          })\n          .join('\\n');\n\n        if (value !== nextValue) {\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: nextValue,\n            // Move the start cursor if first line in selection was modified\n            // It was modified only if it started with a tab\n            selectionStart: startLineText.startsWith(tabCharacter)\n              ? selectionStart - tabCharacter.length\n              : selectionStart,\n            // Move the end cursor by total number of characters removed\n            selectionEnd: selectionEnd - (value.length - nextValue.length),\n          });\n        }\n      } else if (selectionStart !== selectionEnd) {\n        // Indent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const startLineText = linesBeforeCaret[startLine];\n\n        this._applyEdits({\n          value: value\n            .split('\\n')\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            })\n            .join('\\n'),\n          // Move the start cursor by number of characters added in first line of selection\n          // Don't move it if it there was no text before cursor\n          selectionStart: /\\S/.test(startLineText)\n            ? selectionStart + tabCharacter.length\n            : selectionStart,\n          // Move the end cursor by total number of characters added\n          selectionEnd:\n            selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n        });\n      } else {\n        const updatedSelection = selectionStart + tabCharacter.length;\n\n        this._applyEdits({\n          // Insert tab character at caret\n          value:\n            value.substring(0, selectionStart) +\n            tabCharacter +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (e.keyCode === KEYCODE_BACKSPACE) {\n      const hasSelection = selectionStart !== selectionEnd;\n      const textBeforeCaret = value.substring(0, selectionStart);\n\n      if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n        // Prevent default delete behaviour\n        e.preventDefault();\n\n        const updatedSelection = selectionStart - tabCharacter.length;\n\n        this._applyEdits({\n          // Remove tab character at caret\n          value:\n            value.substring(0, selectionStart - tabCharacter.length) +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (e.keyCode === KEYCODE_ENTER) {\n      // Ignore selections\n      if (selectionStart === selectionEnd) {\n        // Get the current line\n        const line = this._getLines(value, selectionStart).pop();\n        const matches = line.match(/^\\s+/);\n\n        if (matches && matches[0]) {\n          e.preventDefault();\n\n          // Preserve indentation on inserting a new line\n          const indent = '\\n' + matches[0];\n          const updatedSelection = selectionStart + indent.length;\n\n          this._applyEdits({\n            // Insert indentation character at caret\n            value:\n              value.substring(0, selectionStart) +\n              indent +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      }\n    } else if (\n      e.keyCode === KEYCODE_PARENS ||\n      e.keyCode === KEYCODE_BRACKETS ||\n      e.keyCode === KEYCODE_QUOTE ||\n      e.keyCode === KEYCODE_BACK_QUOTE\n    ) {\n      let chars;\n\n      if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n        chars = ['(', ')'];\n      } else if (e.keyCode === KEYCODE_BRACKETS) {\n        if (e.shiftKey) {\n          chars = ['{', '}'];\n        } else {\n          chars = ['[', ']'];\n        }\n      } else if (e.keyCode === KEYCODE_QUOTE) {\n        if (e.shiftKey) {\n          chars = ['\"', '\"'];\n        } else {\n          chars = [\"'\", \"'\"];\n        }\n      } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n        chars = ['`', '`'];\n      }\n\n      // If text is selected, wrap them in the characters\n      if (selectionStart !== selectionEnd && chars) {\n        e.preventDefault();\n\n        this._applyEdits({\n          value:\n            value.substring(0, selectionStart) +\n            chars[0] +\n            value.substring(selectionStart, selectionEnd) +\n            chars[1] +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart,\n          selectionEnd: selectionEnd + 2,\n        });\n      }\n    } else if (\n      (isMacLike\n        ? // Trigger undo with ⌘+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z\n        : // Trigger undo with Ctrl+Z on other platforms\n          e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n      !e.shiftKey &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._undoEdit();\n    } else if (\n      (isMacLike\n        ? // Trigger redo with ⌘+Shift+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n        : isWindows\n          ? // Trigger redo with Ctrl+Y on Windows\n            e.ctrlKey && e.keyCode === KEYCODE_Y\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._redoEdit();\n    } else if (\n      e.keyCode === KEYCODE_M &&\n      e.ctrlKey &&\n      (isMacLike ? e.shiftKey : true)\n    ) {\n      e.preventDefault();\n\n      // Toggle capturing tab key so users can focus away\n      this.setState(state => ({\n        capture: !state.capture,\n      }));\n    }\n  };\n\n  _handleChange = (e: *) => {\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    this._recordChange(\n      {\n        value,\n        selectionStart,\n        selectionEnd,\n      },\n      true\n    );\n\n    this.props.onValueChange(value);\n  };\n\n  _history: History = {\n    stack: [],\n    offset: -1,\n  };\n\n  _input: ?HTMLTextAreaElement;\n\n  get session() {\n    return {\n      history: this._history,\n    };\n  }\n\n  set session(session: { history: History }) {\n    this._history = session.history;\n  }\n\n  render() {\n    const {\n      value,\n      style,\n      padding,\n      highlight,\n      textareaId,\n      autoFocus,\n      disabled,\n      form,\n      maxLength,\n      minLength,\n      name,\n      placeholder,\n      readOnly,\n      required,\n      onClick,\n      onFocus,\n      onBlur,\n      onKeyUp,\n      /* eslint-disable no-unused-vars */\n      onKeyDown,\n      onValueChange,\n      tabSize,\n      insertSpaces,\n      ignoreTabKey,\n      /* eslint-enable no-unused-vars */\n      ...rest\n    } = this.props;\n\n    const contentStyle = {\n      paddingTop: padding,\n      paddingRight: padding,\n      paddingBottom: padding,\n      paddingLeft: padding,\n    };\n\n    const highlighted = highlight(value);\n\n    return (\n      <div {...rest} style={{ ...styles.container, ...style }}>\n        <textarea\n          ref={c => (this._input = c)}\n          style={{\n            ...styles.editor,\n            ...styles.textarea,\n            ...contentStyle,\n          }}\n          className={className}\n          id={textareaId}\n          value={value}\n          onChange={this._handleChange}\n          onKeyDown={this._handleKeyDown}\n          onClick={onClick}\n          onKeyUp={onKeyUp}\n          onFocus={onFocus}\n          onBlur={onBlur}\n          disabled={disabled}\n          form={form}\n          maxLength={maxLength}\n          minLength={minLength}\n          name={name}\n          placeholder={placeholder}\n          readOnly={readOnly}\n          required={required}\n          autoFocus={autoFocus}\n          autoCapitalize=\"off\"\n          autoComplete=\"off\"\n          autoCorrect=\"off\"\n          spellCheck={false}\n          data-gramm={false}\n        />\n        <pre\n          aria-hidden=\"true\"\n          style={{ ...styles.editor, ...styles.highlight, ...contentStyle }}\n          {...(typeof highlighted === 'string'\n            ? { dangerouslySetInnerHTML: { __html: highlighted + '<br />' } }\n            : { children: highlighted })}\n        />\n        {/* eslint-disable-next-line react/no-danger */}\n        <style type=\"text/css\" dangerouslySetInnerHTML={{ __html: cssText }} />\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden',\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent',\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none',\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word',\n  },\n};\n"]},"metadata":{},"sourceType":"script"}